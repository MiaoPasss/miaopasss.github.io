<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"miaopasss.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="赤团开时斜飞去， 最不安神晴又复雨。">
<meta property="og:type" content="website">
<meta property="og:title" content="乌啦呀哈呀哈乌啦！">
<meta property="og:url" content="https://miaopasss.github.io/index.html">
<meta property="og:site_name" content="乌啦呀哈呀哈乌啦！">
<meta property="og:description" content="赤团开时斜飞去， 最不安神晴又复雨。">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Haotian Luo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://miaopasss.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>乌啦呀哈呀哈乌啦！</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">乌啦呀哈呀哈乌啦！</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临，这里是喵pass的个人博客，希望有能帮到你的地方
</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页 | Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类 | Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签 | Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档 | Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/miaopasss" class="github-corner" title="Check out my GitHub" aria-label="Check out my GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2026/02/11/%E7%BA%BF%E6%80%A7%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/11/%E7%BA%BF%E6%80%A7%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="post-title-link" itemprop="url">线性与非线性表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2026-02-11 16:42:00 / Modified: 17:01:13" itemprop="dateCreated datePublished" datetime="2026-02-11T16:42:00+08:00">2026-02-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>线性：一头一尾，每个元素只有一个前驱和一个后驱，比如栈&#x2F;队列<br>非线性：分支、分层关系，比如树&#x2F;图</p>
<hr>
<h1 id="物理结构和逻辑结构"><a href="#物理结构和逻辑结构" class="headerlink" title="物理结构和逻辑结构"></a>物理结构和逻辑结构</h1><p><strong>数组和链表可以看做物理存储的概念。</strong><br>数组是用一段连续的内存存储，可以随机访问，支持随机访问（ O(1) ），但增删需移动元素（ O(n) ）。<br>链表不要求连续的内存，元素分散存储，通过指针连接，增删无需移动元素（ O(1) ），但不支持随机访问（ O(n) ）。</p>
<p><strong>而数据结构都是逻辑层的概念，线性表，非线性表，栈，队列，树，图等等。</strong><br>线性表这些逻辑层的概念，底层既可以用数组实现，也可以用链表实现。线性表用数组实现就叫做顺序表。</p>
<p>“顺序表是在计算机内存中以数组的形式保存的线中以数组的形式保存的线性表。” 简而言之，是线性表的一种实现方式。显然，这里的“数组”指物理结构，“线性表”指逻辑结构。这个解释应该还是合理的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2026/02/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">面向对象与虚函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2026-02-11 15:17:32 / Modified: 16:38:08" itemprop="dateCreated datePublished" datetime="2026-02-11T15:17:32+08:00">2026-02-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h1><ul>
<li><p>封装 Encapsulation<br>将客观事物抽象为类，隐藏对象的内部属性和实现细节，只通过对外提供的公开接口（如 getter&#x2F;setter）进行访问。</p>
</li>
<li><p>继承 Inheritance<br>一个类（子类&#x2F;派生类）从另一个类（父类&#x2F;基类）中继承属性和方法，同时可以扩展新的功能，实现代码复用减少冗余。</p>
</li>
<li><p>多态 Polymorphism<br>同一接口在不同情形下有不同的表现形式。简单来说，即父类指针或引用指向子类对象，并调用子类重写后的方法。<br>如果多个派生类同时实现了一个接口，通过实例化此接口也可以展现出多态的特性。</p>
</li>
</ul>
<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>当继承链中虚函数 &gt;&#x3D; 1，则在compile time编译时生成虚函数表vtable映射到虚函数<br>继承链中的每个包含虚函数的类都有一个属于自己的 vtable (虚函数表)<br>在runtime运行时，子类的构造函数中为vptr赋值指向vtable</p>
<p>父类指针调用虚函数时，子类复写的虚函数被调用<br>查询vtable找到虚函数的入口地址并执行<br>父类指针指向子类对象，或父类引用绑定子类对象，父类对象vptr变成子类对象vptr，查询子类vtable</p>
<h2 id="virtual-vs-new"><a href="#virtual-vs-new" class="headerlink" title="virtual vs. new"></a>virtual vs. new</h2><p><img src="/2026/02/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/p1.png" title="不同情况下的同名函数"> <br></p>
<p><u><strong>Note:</strong></u> <em>virtual</em> + <em>override</em> are resolved at runtime (so <em>override</em> really overrides <em>virtual</em> methods), while <em>new</em> just create new method with the same name, and hides the old, it is resolved at compile time -&gt; your compiler will call the method it ‘sees’.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2026/02/09/HybridCLR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/09/HybridCLR/" class="post-title-link" itemprop="url">HybridCLR简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2026-02-09 17:31:56 / Modified: 17:57:42" itemprop="dateCreated datePublished" datetime="2026-02-09T17:31:56+08:00">2026-02-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HybridCLR扩充了IL2CPP的代码，使它由纯AOT Runtime变成“AOT+Interpreter“混合Runtime，进而原生支持动态加载Assembly，使得基于IL2CPP Backend打包的游戏不仅能在Android平台，也能在iOS、Consoles等限制了JIT的平台上高效地以AOT+interpreter混合模式执行。</p>
<p>通过 “Differential Hybrid dll” 技术，可以对 AOT dll 实现任意增删改，会智能地让<em>被修改或者新增的类和方法</em>以 Interpreter 模式运行，但 <em>未被修改的类</em> 以AOT方式运行，从而使<em>热更新的游戏逻辑</em>的运行性能基本达到原生AOT的水平。</p>
<hr>
<h1 id="基础原理"><a href="#基础原理" class="headerlink" title="基础原理"></a>基础原理</h1><p>CLR，即Common Language Runtime，中文叫公共语言运行时，是让.NET程序执行所需的外部服务的集合，是.NET平台的核心和最重要的组件，类似于Java的JVM。</p>
<p>IL2CPP是Unity开发的跨平台CLR解决方案，诞生它的一个关键原因是Unity需要跨平台运行。但一些平台如iOS，这种禁止JIT并导致依赖JIT的官方CLR虚拟机无法运行，而是必须使用AOT技术将Mananged程序提前转化为目标平台的静态原生程序后再运行。而Mono虽然也支持AOT，但性能较差以及跨平台支持不佳。The IL2CPP backend converts MSIL (Microsoft Intermediate Language) code (for example, C# code in scripts) into C++ code, then uses the C++ code to create a native binary file (for example, .exe, .apk, or .xap) for your chosen platform.</p>
<p>IL2CPP方案包含一套AOT运行时以及一套DLL到C++代码及元数据的转换工具，使得原始的C#开发的代码最终能在iOS这样的平台运行起来。因为 IL2CPP 生成的 C++ 代码不是普通的 C++，它本质上还是在模拟 C# 的行为。很多 C# 特性在 C++ 里根本不存在，必须有额外代码来支撑。IL2CPP 只是把计算逻辑翻译成了 C++，但 C# 作为托管语言的那些”托管服务”，必须由运行时来提供。生成的 C++ 代码到处都在调用 il2cpp_xxx() 这类运行时 API，离开运行时根本跑不起来。</p>
<p>IL2CPP是一个纯静态的AOT运行时，不支持运行时加载DLL，因此不支持热更新；不像Mono有Hybrid mode execution，可支持动态加载DLL。</p>
<p>目前Unity平台的主流热更新方案xLua、ILRuntime之类都是引入一个第三方VM（Virtual Machine），在VM中解释执行代码，来实现热更新。这里我们只分析使用C#为开发语言的热更新方案。这些热更新方案的VM与IL2CPP是独立的，意味着它们的元数据系统是不相通的，在热更新里新增一个类型是无法被IL2CPP所识别的（例如，通过System.Activator.CreateInstance是不可能创建出这个热更新类型的实例），这种看起来像，但实际上又不是的伪CLR虚拟机，在与IL2CPP这种复杂的CLR运行时交互时，会产生极大量的兼容性问题，另外还有严重的性能问题。</p>
<p>HybridCLR 对 IL2CPP运行时进行扩充，添加Interpreter模块，将它由AOT运行时改造为“AOT + interpreter”双引擎的混合运行时，进而实现Mono hybrid mode execution这样的机制。这样一来就能彻底支持热更新，并且兼容性极佳。对开发者来说，除了解释模式运行的部分执行得比较慢，其他方面跟标准的运行时没有区别，完美支持在iOS这种禁止JIT的平台上以解释模式无缝地运行动态加载的DLL。</p>
<h1 id="与其他热更新方案对比"><a href="#与其他热更新方案对比" class="headerlink" title="与其他热更新方案对比"></a>与其他热更新方案对比</h1><p>HybridCLR是原生的C#热更新方案。通俗地说，IL2CPP相当于Mono的AOT模块，HybridCLR相当于Mono的Interpreter模块，两者合一成为完整Mono。HybridCLR使得IL2CPP变成一个全功能的Runtime，原生（即通过System.Reflection.Assembly.Load）支持动态加载DLL，从而支持iOS平台的热更新。</p>
<p>正因为HybridCLR是原生Runtime级别实现，热更新部分的类型与主工程AOT部分类型是完全等价并且无缝统一的。可以随意调用、继承、反射或多线程，不需要生成代码或者写适配器。</p>
<p>其他热更新方案则是独立VM，与IL2CPP的关系本质上相当于Mono中嵌入Lua的关系。因此类型系统不统一，为了让热更新类型能够继承AOT部分类型，需要写适配器，并且解释器中的类型不能为主工程的类型系统所识别。特性不完整、开发麻烦、运行效率低下。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2026/02/04/%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%8A%A8%E7%94%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/04/%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%8A%A8%E7%94%BB/" class="post-title-link" itemprop="url">模型和动画</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2026-02-04 20:37:14" itemprop="dateCreated datePublished" datetime="2026-02-04T20:37:14+08:00">2026-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2026-02-09 17:10:29" itemprop="dateModified" datetime="2026-02-09T17:10:29+08:00">2026-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Animation/" itemprop="url" rel="index"><span itemprop="name">Animation</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关节坐标的定义和计算方法"><a href="#关节坐标的定义和计算方法" class="headerlink" title="关节坐标的定义和计算方法"></a>关节坐标的定义和计算方法</h1><ol>
<li>绑定姿势：这是网格绑定到骨骼之前的姿势，通常是设计师在绑定模型时预设的。绑定姿势通常在一个T型姿势（T-Pose）下进行记录‌。</li>
<li>局部姿势：这是关节相对于父关节来指定的常见姿势。局部姿势存储为TQS格式，表示相对于父关节的位置、朝向和缩放。根关节的父节点可以认为是世界坐标系的原点。在数学上，关节姿势是一个仿射变换，由平移向量、旋转矩阵和对角缩放矩阵组成‌。</li>
</ol>
<p>骨架由一系列具有层次关系的关节（骨骼）和关节链组成，是一种树结构，选择其中一个是根关节，其它关节是根关节的子孙，可以通过平移和旋转根关节移动并确定整个骨架在世界空间中的位置和方向。父关节运动能影响子关节运动，但子关节运动对父关节不产生影响，因此，平移或旋转父关节时，也会同时平移或旋转其所有子关节。</p>
<p><img src="/2026/02/04/%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%8A%A8%E7%94%BB/p1.png" title="骨骼节点的父子关系"> <br></p>
<h1 id="Unity动画系统"><a href="#Unity动画系统" class="headerlink" title="Unity动画系统"></a>Unity动画系统</h1><p>分为旧版动画系统和新版动画系统，即AnimationClip 与 Animator（Mecanim）</p>
<ul>
<li><p>AnimationClip<br>Plays specific Animation Clips directly via script (e.g., Animation.Play(“Jump”)). It has no built-in state machine or visual graph.</p>
</li>
<li><p>Animator&#x2F;Mecanim (New)<br>Attach a animator component to your GameObject. It requires an Animator Controller asset to function.<br>It uses a visual graph to manage states. You rarely tell it to “Play” a clip; instead, you change a parameter (e.g., animator.SetFloat(“Speed”, 5.0f)), and the state machine decides which animation to play.</p>
</li>
</ul>
<h1 id="3D模型"><a href="#3D模型" class="headerlink" title="3D模型"></a>3D模型</h1><ol>
<li>绑定 (Rigging)<br>指为3D模型创建内部骨骼、关节及控制器系统，定义运动逻辑，给角色搭建“骨架”和“控制系统”的过程，类似于给木偶安装操纵线。</li>
</ol>
<ul>
<li>目的： 赋予模型生命，使动画师能方便地操纵复杂的几何体。</li>
<li>组成： 包含骨骼（Joints）、控制器（Controllers）、IK&#x2F;FK（逆向&#x2F;正向动力学）链。<br>工作内容： 放置关节、设置骨骼层级、添加IK把手、创建控制器。</li>
</ul>
<ol start="2">
<li>蒙皮 (Skinning)<br>蒙皮是绑定完成后的步骤，将模型的顶点（Vertex）“绑定”到骨骼上。<br>目的： 让骨骼驱动模型网格变形。当骨骼移动时，皮肤上的顶点会随之移动。<br>方法：</li>
</ol>
<ul>
<li>平滑蒙皮（Smooth Skinning）： 顶点受多个骨骼影响，变形平滑自然（最常用）。</li>
<li>刚性蒙皮（Rigid Skinning）： 一个顶点只受一个骨骼影响，变形较生硬。<br><strong>关键概念——刷权重（Weighting）： 定义顶点受特定骨骼影响的程度（0-1之间）。将Mesh网格的顶点与骨骼节点对应，从而决定模型的不同部位要跟着关节位移的程度</strong></li>
</ul>
<ol start="3">
<li>制作关键帧动画<br>IK骨（Inverse Kinematics，反向动力学）通过设置骨骼末端（如手、脚）的目标位置，计算系统会自动推算出其他关节（如手腕、肘部）的移动</li>
</ol>
<ul>
<li>IK骨不是被反推的骨头的子节点，而是以外的骨头（例如大腿-&gt;小腿-&gt;脚，此时IK骨则不为这三个骨头的子节点）</li>
<li>Chain Length：有多少根节点骨头要反算</li>
<li>Pole Target：被影响关节的朝向方向</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/09/18/%E7%9D%80%E8%89%B2%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/18/%E7%9D%80%E8%89%B2%E5%99%A8/" class="post-title-link" itemprop="url">着色器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-18 16:43:49" itemprop="dateCreated datePublished" datetime="2025-09-18T16:43:49+08:00">2025-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-29 10:10:03" itemprop="dateModified" datetime="2025-09-29T10:10:03+08:00">2025-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Graphics/" itemprop="url" rel="index"><span itemprop="name">Graphics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="顶点着色器-vs-片元着色器"><a href="#顶点着色器-vs-片元着色器" class="headerlink" title="顶点着色器 vs 片元着色器"></a>顶点着色器 vs 片元着色器</h1><p>One main difference is that a vertex shader can manipulate the attributes of vertices. which are the corner points of your polygons.<br>The fragment shader on the other hand takes care of how the pixels between the vertices look. They are interpolated between the defined vertices following specific rules.</p>
<p>白话：顶点着色器负责定位三角形位置！片段着色器负责修改像素颜色！！</p>
<h1 id="顶点着色器-Vertex-Shader"><a href="#顶点着色器-Vertex-Shader" class="headerlink" title="顶点着色器(Vertex Shader)"></a>顶点着色器(Vertex Shader)</h1><p>顶点着色器是图形渲染管线中的第一个可编程阶段。它的主要任务是处理从CPU发送到GPU的顶点数据。每个顶点都会通过顶点着色器进行一次，通常用于执行以下操作：</p>
<ul>
<li>变换：将顶点从模型空间转换到世界空间，然后进一步转换到视图空间和投影空间。这通常涉及到矩阵乘法运算，用于实现平移、旋转和缩放等变换。</li>
<li>光照计算（可选）：在某些情况下，顶点着色器也用于执行初步的光照计算，但这通常是在更简单的渲染场景中，或者作为更复杂的片元级光照计算的一个初步步骤。</li>
<li>传递数据：顶点着色器可以计算并传递额外的数据到后续的渲染阶段，如片元着色器。这些数据可以是颜色、纹理坐标或其他自定义属性。</li>
</ul>
<h1 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h1><p>片元着色器是图形渲染管线中处理像素级渲染的阶段。它接收由顶点着色器插值得到的片元（即屏幕上的像素或像素的候选者），并生成最终的颜色和其他与像素相关的数据。以下是片元着色器的一些主要用途：</p>
<ul>
<li>纹理映射：从纹理中读取颜色信息，并应用到相应的像素上。这可以用于实现贴图、细节增强等效果。</li>
<li>光照计算：执行更详细的光照计算，如计算每个像素上的光照强度和颜色。这可以包括漫反射、镜面反射、环境光等多种光照模型。</li>
<li>颜色混合和特殊效果：实现各种颜色混合模式，以及应用如模糊、发光、深度测试等后处理效果。</li>
<li>输出最终颜色：基于上述计算，确定每个像素的最终颜色，并将其发送到渲染管线的下一个阶段（通常是帧缓冲区）。</li>
</ul>
<hr>
<h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits:"></a>Credits:</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/718015588">https://zhuanlan.zhihu.com/p/718015588</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/09/05/%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4%E5%92%8CNDC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/05/%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4%E5%92%8CNDC/" class="post-title-link" itemprop="url">裁剪空间和NDC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-05 11:35:46" itemprop="dateCreated datePublished" datetime="2025-09-05T11:35:46+08:00">2025-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2026-02-04 20:36:17" itemprop="dateModified" datetime="2026-02-04T20:36:17+08:00">2026-02-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Graphics/" itemprop="url" rel="index"><span itemprop="name">Graphics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Vertex Shader的输出在Clip Space，然后GPU自己做透视除法变到了NDC( 取值范围[-1, 1] )。</p>
<hr>
<h1 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h1><p>裁剪空间变换的思路是，对平截头体进行缩放，使近裁剪面和远裁剪面变成正方形，使坐标的w分量表示裁剪范围，此时，只需要简单的比较x,y,z和w分量的大小即可裁剪图元。<br>完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，与这块空间边界相交的图元就会被裁剪。而这块空间就是由视椎体来决定的。</p>
<p>In clip space, clipping is not done against a unit cube. It is done against a cube with side-length w. Points are inside the visible area if each of their x,y,z coordinate is smaller than their w coordinate.</p>
<p>In the example you have, the point [6, 0, 6.29, 7] is visible because all three coordinates (x,y,z) are smaller than 7.</p>
<h2 id="透视投影矩阵"><a href="#透视投影矩阵" class="headerlink" title="透视投影矩阵"></a>透视投影矩阵</h2><p><img src="/2025/09/05/%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4%E5%92%8CNDC/p1.jpg" title="Perspective Projection Matrix"> <br></p>
<p>此时我们就可以按如下不等式来判断一个变换后的顶点是否位于视椎体内<br><img src="/2025/09/05/%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4%E5%92%8CNDC/p3.png" title="Clipping"> <br></p>
<h2 id="正交投影矩阵"><a href="#正交投影矩阵" class="headerlink" title="正交投影矩阵"></a>正交投影矩阵</h2><p><img src="/2025/09/05/%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4%E5%92%8CNDC/p2.jpg" title="Orthogonal Projection Matrix"> <br></p>
<p>判断一个变换后的顶点是否位于视椎体内使用的不等式和透视投影中的一样，这种通用性也是为什么要使用投影矩阵的原因之一。</p>
<hr>
<h1 id="NDC"><a href="#NDC" class="headerlink" title="NDC"></a>NDC</h1><p>齐次除法将Clip Space顶点的4个分量都除以w分量，就从Clip Space转换到了NDC了。<br>而NDC是一个长宽高取值范围为[-1, 1]的立方体，超过这个范围的顶点，会被GPU剪裁。也就是说，每个顶点的x，y，z坐标都应该在-1.0到1.0之间，超出这个坐标范围的顶点都将不可见。</p>
<h2 id="透视投影除法"><a href="#透视投影除法" class="headerlink" title="透视投影除法"></a>透视投影除法</h2><p><img src="/2025/09/05/%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4%E5%92%8CNDC/p5.png" title="齐次除法"></p>
<h2 id="正交投影除法"><a href="#正交投影除法" class="headerlink" title="正交投影除法"></a>正交投影除法</h2><p><img src="/2025/09/05/%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4%E5%92%8CNDC/p6.png" title="齐次除法"> <br></p>
<p>细心一点会发现，齐次坐标对于透视投影空的裁剪空间变化更大，而对正交投影的裁剪空间没有影响（正交投影的裁剪空间中顶点的w已经是1了）。</p>
<h2 id="视口变换-Viewport-Transformation"><a href="#视口变换-Viewport-Transformation" class="headerlink" title="视口变换(Viewport Transformation)"></a>视口变换(Viewport Transformation)</h2><p>At this moment, we’re still in 3D space.How do we get to 2D space?</p>
<p>We need to transform our vertex from 3D NDC to 2D screen coordinates.</p>
<p>When initializing the Canvas, we are responsible for configuring its size. This size is used to convert our NDC coordinates to screen coordinates.</p>
<p><img src="/2025/09/05/%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4%E5%92%8CNDC/p4.png" title="viewport transformation"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/08/28/C-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/28/C-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/" class="post-title-link" itemprop="url">C# 依赖注入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-28 16:30:54 / Modified: 17:33:12" itemprop="dateCreated datePublished" datetime="2025-08-28T16:30:54+08:00">2025-08-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="No-Dependency-Injection"><a href="#No-Dependency-Injection" class="headerlink" title="No Dependency Injection"></a>No Dependency Injection</h1><p>不使用依赖注入，必须在依赖方(Dependent Class)中主动创建或者获取被依赖方(Denpendency Class)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClassA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ClassB _classB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassA</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _classB = <span class="keyword">new</span> ClassB(); <span class="comment">//主动创建对象B</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Process</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Class A start process&quot;</span>);</span><br><span class="line">        _classB.DoSomething();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Class A finish process&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClassB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ClassB performs some logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Denpendency-Injection-and-IoC"><a href="#Denpendency-Injection-and-IoC" class="headerlink" title="Denpendency Injection and IoC"></a>Denpendency Injection and IoC</h1><p>使用依赖注入，不需要在依赖方的代码里主动创建或者获取被依赖方，反而，只需要在构造器参数里声明需要对象B的引用。</p>
<figure class="highlight cs"><figcaption><span>ClassA.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClassA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IInterfaceB _b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassA</span>(<span class="params">IInterfaceB b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Process</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Class A start process&quot;</span>);</span><br><span class="line">        _b.DoSomething();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Class A finish process&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用依赖注入时，更多时候，对于依赖更提倡使用接口，这样解耦了接口和实现：ClassA不需要知道ClassB的内部，只需要知道IClassB有个叫DoSomething的方法可以调用<br>并且，业务代码中不需要主动实例化对象，即无需这样主动调用构造函数 new ClassA(new ClassB())</p>
<figure class="highlight cs"><figcaption><span>ClassB.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClassB</span> : <span class="title">IClassB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;class B is doing something ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>IClassB.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IClassB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>Program.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IHost host = Host.CreateDefaultBuilder(<span class="keyword">args</span>)</span><br><span class="line">                        .ConfigureServices((context, services) =&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            services.AddSingleton&lt;ClassA&gt;();</span><br><span class="line">                            services.AddSingleton&lt;IInterfaceB, ClassB&gt;();</span><br><span class="line">                        &#125;).Build();</span><br><span class="line"></span><br><span class="line">        ClassA a = host.Services.GetRequiredService&lt;ClassA&gt;();</span><br><span class="line">        a.Process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原本是在ClassA内部决定使用怎样的ClassB实例，使用了依赖注入设计后，这种控制关系（决定关系）变为由外部控制了，这就是所谓的“控制反转”(Inversion of Control)</p>
<ul>
<li>Host 以及它内部的 Services可以理解为 C# 提供的依赖注入系统</li>
<li>通过 GetRequiredService 可以获得对应的实例并执行业务逻辑（此处为ClassA实例）</li>
</ul>
<h1 id="使用依赖注入系统实例化对象"><a href="#使用依赖注入系统实例化对象" class="headerlink" title="使用依赖注入系统实例化对象"></a>使用依赖注入系统实例化对象</h1><p>如果我们想要达到不需要手动实例化ClassA的效果，可以新建一个类并实现IHostedService接口</p>
<figure class="highlight cs"><figcaption><span>DoSomethingHostedService.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DoSomethingHostedService</span> : <span class="title">IHostedService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ClassA _a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoSomethingHostedService</span>(<span class="params">ClassA a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StartAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _a.Process();</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StopAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>修改 Program.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IHost host = Host.CreateDefaultBuilder(<span class="keyword">args</span>)</span><br><span class="line">                        .ConfigureServices((context, services) =&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            services.AddSingleton&lt;ClassA&gt;();</span><br><span class="line">                            services.AddSingleton&lt;IInterfaceB, ClassB&gt;();</span><br><span class="line"></span><br><span class="line">                            services.AddHostedService&lt;DoSomethingHostedService&gt;();</span><br><span class="line">                        &#125;).Build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> host.RunAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>IHostedService 是一个特殊的接口，实现这个接口的类通过在Host中的services里注册后，可以在Host运行时自动实例化并执行</li>
<li>services.AddHostedService&lt;&gt;() 用于注册要自动执行的类</li>
<li>await host.RunAsync() 运行Host实例</li>
</ul>
<hr>
<h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits:"></a>Credits:</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/592698341">https://zhuanlan.zhihu.com/p/592698341</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/08/26/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8CMVP%E5%8F%98%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/26/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8CMVP%E5%8F%98%E6%8D%A2/" class="post-title-link" itemprop="url">坐标空间和MVP变换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-26 17:47:30" itemprop="dateCreated datePublished" datetime="2025-08-26T17:47:30+08:00">2025-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-05 17:42:25" itemprop="dateModified" datetime="2025-09-05T17:42:25+08:00">2025-09-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Graphics/" itemprop="url" rel="index"><span itemprop="name">Graphics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2025/08/26/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8CMVP%E5%8F%98%E6%8D%A2/p9.png" title="空间变换总览"></p>
<p>坐标空间有：世界空间、模型空间、摄像机空间、齐次裁剪空间、屏幕空间，以及法线映射会用到的切线空间（之前的纹理基础篇就讲到过）。 </p>
<p><strong>那为什么会有这么多个坐标空间呢？</strong></p>
<blockquote>
<p>一些概念只有在特定的坐标空间下才有意义，才更容易理解。这就是为什么在渲染中我们要使用这么多坐标空间。</p>
</blockquote>
<div style="text-align: right">——《Unity Shader 入门精要》</div>

<hr>
<ul>
<li>坐标空间转换：在渲染管线中，把一个点或一个向量从一个坐标空间转换到另一个坐标空间，比如模型空间 -&gt; 裁剪空间</li>
<li>变换矩阵：实现坐标空间转换的过程，则需要用到变换矩阵</li>
<li>顶点着色器：顶点着色器是图形渲染管线中对每个顶点进行坐标变换的程序，而MVP变换（模型Model - 视图View - 投影Projection）是顶点着色器中一种将顶点坐标从模型空间转换为裁剪空间的常用技术。</li>
</ul>
<hr>
<h1 id="1-模型空间-Model-Space"><a href="#1-模型空间-Model-Space" class="headerlink" title="1. 模型空间(Model Space)"></a>1. 模型空间(Model Space)</h1><p>又称为对象空间(Object Space)或局部空间(Local Space)，每个模型都有属于自己的模型空间</p>
<ul>
<li>以模型本身为参考系，会随着模型的旋转&#x2F;移动而旋转&#x2F;移动</li>
<li>包含前、后、左、右等自然方向概念.</li>
</ul>
<p>在模型空间中描述模型上的某一点位置时，坐标会被扩展到齐次坐标系下：(1,0,0) -&gt; (1,0,0,1)，为顶点变换中的平移变换做准备</p>
<h3 id="顶点变换Step-1-模型变换-MVP中的M"><a href="#顶点变换Step-1-模型变换-MVP中的M" class="headerlink" title="顶点变换Step 1 - 模型变换(MVP中的M)"></a>顶点变换Step 1 - 模型变换(MVP中的M)</h3><p>Model Transformation 把3D物体从模型空间变换到世界空间</p>
<p><img src="/2025/08/26/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8CMVP%E5%8F%98%E6%8D%A2/p1.png" title="cube坐标变换前"></p>
<p>在Unity中，我们直接给Cube拖出来就行</p>
<p><img src="/2025/08/26/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8CMVP%E5%8F%98%E6%8D%A2/p2.png" title="cube坐标变换后"></p>
<p>我们发现，Cube位置从(0, 2, 4, 1) -&gt; (9, 4, 18.071)，unity帮助我们把Cube的坐标完成了模型变换</p>
<hr>
<h1 id="2-世界空间-World-Space"><a href="#2-世界空间-World-Space" class="headerlink" title="2. 世界空间(World Space)"></a>2. 世界空间(World Space)</h1><p>游戏场景中的最大空间，一般世界空间的原点会放在游戏空间的正中心，同时世界空间的位置就是绝对位置——这个绝对位置你可以理解成Unity里没有父节点（parent）的游戏对象的位置。</p>
<h3 id="顶点变换Step-2-观察变换-MVP中的V"><a href="#顶点变换Step-2-观察变换-MVP中的V" class="headerlink" title="顶点变换Step 2 - 观察变换(MVP中的V)"></a>顶点变换Step 2 - 观察变换(MVP中的V)</h3><p>View Transformation 把3D物体从世界空间变换到观察空间</p>
<p>此时的变换矩阵等于：把观察空间当做一个模型空间，将其变换到世界空间（用模型变换的方法），然后取此变换矩阵的逆即为 观察空间 &lt;- 世界空间</p>
<p><img src="/2025/08/26/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8CMVP%E5%8F%98%E6%8D%A2/p4.png" title="cube坐标变换前"></p>
<p>在unity中，我们可以直接把Cube从世界空间拖到Main Camera下，此时Cube的Transform组件变为观察空间下的坐标信息</p>
<p><img src="/2025/08/26/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8CMVP%E5%8F%98%E6%8D%A2/p5.png" title="cube坐标变换后"></p>
<p>我们发现Cube位置变为(9, 8.839, 27.310)，但此时Transform信息是左手坐标系下的，因此正确描述在观察空间中的Cube坐标应为(9, 8.839, -27.310)</p>
<hr>
<h1 id="3-观察空间-View-Space"><a href="#3-观察空间-View-Space" class="headerlink" title="3. 观察空间(View Space)"></a>3. 观察空间(View Space)</h1><p>也叫做摄像机空间(Camera Space)，摄像机在场景中不可见，但是一般会给它生成一个图标并在场景窗口可视化，例如：</p>
<p><img src="/2025/08/26/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8CMVP%E5%8F%98%E6%8D%A2/p3.png" title="摄像机在场景中可视化"></p>
<ul>
<li>In Unity’s camera&#x2F;view space, the forward direction (the direction the camera is looking) is along the negative Z-axis. This means objects further away from the camera will have larger negative Z values in view space.</li>
<li>注意区分<em>观察空间</em>和<em>屏幕空间</em>，观察空间是3d，屏幕空间是2d，观察空间 -&gt; 屏幕空间需要经过投影操作</li>
</ul>
<h3 id="顶点变换Step-3-投影变换-MVP中的P"><a href="#顶点变换Step-3-投影变换-MVP中的P" class="headerlink" title="顶点变换Step 3 - 投影变换(MVP中的P)"></a>顶点变换Step 3 - 投影变换(MVP中的P)</h3><p>Projection Transformation 把3D物体从观察空间变换到裁剪空间</p>
<p>观察空间-&gt;裁剪空间的变换矩阵有更准确的称呼 —— 裁剪矩阵(Clipping Matrix)，也被叫做投影矩阵(Projection Matrix)。<br>此时的坐标为顶点着色器的输出，即图元顶点在裁剪空间中的坐标。</p>
<p><img src="/2025/08/26/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8CMVP%E5%8F%98%E6%8D%A2/p10.jpg" title="投影矩阵"></p>
<hr>
<h1 id="4-裁剪空间-Clip-Space"><a href="#4-裁剪空间-Clip-Space" class="headerlink" title="4. 裁剪空间(Clip Space)"></a>4. 裁剪空间(Clip Space)</h1><p>也被称为其次裁剪空间，渲染管线中几何阶段的裁剪步骤在这一环节完成，这一环节里我们无法操控(Non-programmable)，完全由GPU去做</p>
<h2 id="4-1-视锥体"><a href="#4-1-视锥体" class="headerlink" title="4.1 视锥体"></a>4.1 视锥体</h2><p>从观察空间到屏幕空间的途中，需要经过裁剪空间，其目的在于剔除在视野范围外的图元，而由视锥体(Frustum)决定的裁剪空间为这一剔除过程提供了便利。<br>很显然，场景越大，裁剪的优越性更加突出，如果不进行裁剪就直接投影到2d屏幕空间，后续会产生非常多不必要的开销，例如渲染完全在电脑屏幕外的图元。</p>
<p>视锥体是观察空间中的一块区域，决定着摄像机的可见范围（即最终在屏幕上可见并渲染的物体），它由六个面组成，被称为裁剪平面(Clipping Planes)。</p>
<h2 id="4-1-1-透视投影"><a href="#4-1-1-透视投影" class="headerlink" title="4.1.1 透视投影"></a>4.1.1 透视投影</h2><p><img src="/2025/08/26/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8CMVP%E5%8F%98%E6%8D%A2/p6.png" title="透视投影参数"></p>
<ul>
<li>FOV: 视角度数，同时FOV Axis决定这个视角是横向还是纵向</li>
<li>Clipping Planes: 设置近裁剪平面距离 和 远裁剪平面距离</li>
<li>Viewport Rect: This refers to the Camera.rect property, which defines the portion of the screen where a camera’s view is drawn. By adjusting these values, you can control where a camera renders on the screen and how much of the screen it occupies. This config is commonly used for split-screen effects.</li>
<li>Depth: This property controls the order in which multiple cameras in a scene render their output. A camera with a lower depth value renders before a camera with a higher depth value. This is crucial for achieving effects like picture-in-picture, UI overlays, or rendering specific layers with different cameras. If multiple cameras have the same depth value, their rendering order is determined by their order in the scene hierarchy.</li>
</ul>
<h2 id="4-1-2-正交投影"><a href="#4-1-2-正交投影" class="headerlink" title="4.1.2 正交投影"></a>4.1.2 正交投影</h2><p><img src="/2025/08/26/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8CMVP%E5%8F%98%E6%8D%A2/p7.png" title="正交投影参数"></p>
<h2 id="4-2-投影矩阵的目的"><a href="#4-2-投影矩阵的目的" class="headerlink" title="4.2 投影矩阵的目的"></a>4.2 投影矩阵的目的</h2><p>前面已经讨论过了裁剪的必要性 —— 进行渲染提出视野范围外的图元；这里需要讨论的是，为何不在视锥体裁剪，而是要先变换到裁剪空间再进行裁剪？</p>
<p>《Unity Shader 入门精要》中做了很清楚的解释：“直接在视锥体定义的空间进行裁剪，对于透视投影的视锥体想要判断一个顶点是否在这个空间内是十分麻烦的，我们需要一种更加通用、整洁方便的方式进行裁剪，因此就需要一个投影矩阵将顶点转换到一个裁剪空间(Clip space)中。”</p>
<p>从观察空间到裁剪空间的变换叫做投影变换。虽然叫做投影变换，但是投影变换并没有进行真正的投影。</p>
<h2 id="4-2-1-为真正的投影做准备"><a href="#4-2-1-为真正的投影做准备" class="headerlink" title="4.2.1 为真正的投影做准备"></a>4.2.1 为真正的投影做准备</h2><p>真正的投影可以理解成空间的降维，4d -&gt; 3d，3d -&gt; 2d，真正的投影发生在屏幕映射过程中对顶点进行齐次除法后获得其二维坐标这一步，而投影矩阵只是进行了坐标空间转换，并没有实实在在地进行投影这一操作。<br>齐次（裁剪）空间实质上是一个四维空间，变换到齐次空间的顶点之间仍然是线性相关的，可以使用线性插值。（此时没有除以W变成3D坐标，是齐次坐标）</p>
<h2 id="4-2-2-对x、y、z进行缩放"><a href="#4-2-2-对x、y、z进行缩放" class="headerlink" title="4.2.2 对x、y、z进行缩放"></a>4.2.2 对x、y、z进行缩放</h2><p>投影矩阵虽然叫做投影矩阵，但并没有真正进行投影，而是为投影做准备。经过投影矩阵的缩放后，我们可以直接使用w分量作为范围值，只有x，y，z分量都位于这个范围内的顶点才认为是在裁剪空间内。并且w分量在真正的投影时也会用到。</p>
<hr>
<h1 id="标准化设备坐标-Normalized-Device-Coordinate"><a href="#标准化设备坐标-Normalized-Device-Coordinate" class="headerlink" title="标准化设备坐标(Normalized Device Coordinate)"></a>标准化设备坐标(Normalized Device Coordinate)</h1><p>在齐次裁剪空间的基础上进行透视除法(Perspective division)或称齐次除法(Homogeneous division)，得到的坐标叫做NDC空间坐标。</p>
<ul>
<li>裁剪空间是顶点乘以MVP矩阵之后所在的空间，<strong>Vertex Shader的输出就是在裁剪空间上</strong>（划重点）。</li>
<li>接着由GPU自己做<strong>透视除法</strong>，将顶点转移到标准化设备坐标(NDC)。</li>
</ul>
<p><img src="/2025/08/26/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8CMVP%E5%8F%98%E6%8D%A2/p8.png" title="透视除法"></p>
<hr>
<h1 id="5-屏幕空间-Screen-Space"><a href="#5-屏幕空间-Screen-Space" class="headerlink" title="5. 屏幕空间(Screen Space)"></a>5. 屏幕空间(Screen Space)</h1><p>完成了裁剪工作，下一步就是进行真正的投影了，将视锥体投影到屏幕空间中，这一步会得到真正的像素位置，而不是虚拟的三维坐标。<br>这一环节可以理解为做了以下两步：</p>
<h3 id="5-1-齐次除法"><a href="#5-1-齐次除法" class="headerlink" title="5.1 齐次除法"></a>5.1 齐次除法</h3><p>首先进行标准齐次除法（homogeneous division），也被称为透视除法（perspective division），其实就是x、y、z分别除以w，经过齐次除法后的裁剪空间会变成一个单位立方体，这个立方体空间里的坐标叫做归一化的设备坐标（也就是之前提到的NDC）。因此，也可以说齐次除法是做了空间裁剪坐标到NDC坐标的转换操作。</p>
<h3 id="5-2-屏幕映射（渲染管线中几何阶段的一步）"><a href="#5-2-屏幕映射（渲染管线中几何阶段的一步）" class="headerlink" title="5.2 屏幕映射（渲染管线中几何阶段的一步）"></a>5.2 屏幕映射（渲染管线中几何阶段的一步）</h3><p>这里就顺利的跟之前的渲染管线GPU负责的几何阶段部分联系在一起了。在获得了NDC立方体后，接下来就是根据变换后的x、y坐标映射输出窗口对应的像素坐标，本质就是个缩放的过程。</p>
<ul>
<li>虽然屏幕是2d空间，但z分量此时并没有被抛弃，会被储存起来（深度缓存或者其他的储存格式）</li>
</ul>
<p>我们前面说到Vertex Shader的输出在Clip Space，接着GPU会做透视除法变到NDC。这之后GPU还有一步，应用视口变换(Viewport Transformation)，转换到屏幕空间，输入给Fragment Shader：</p>
<p><strong>(Vertex Shader) &#x3D;&gt; Clip Space &#x3D;&gt; (透视除法) &#x3D;&gt; NDC &#x3D;&gt; (视口变换) &#x3D;&gt; Window Space &#x3D;&gt; (Fragment Shader)</strong></p>
<p><img src="/2025/08/26/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8CMVP%E5%8F%98%E6%8D%A2/p11.png" title="总流程"></p>
<hr>
<h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits:"></a>Credits:</h1><p>MVP矩阵：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41835314/article/details/126851074">https://blog.csdn.net/qq_41835314/article/details/126851074</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/08/14/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/14/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%A7%88/" class="post-title-link" itemprop="url">渲染管线概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-14 17:45:38" itemprop="dateCreated datePublished" datetime="2025-08-14T17:45:38+08:00">2025-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-15 17:58:21" itemprop="dateModified" datetime="2025-08-15T17:58:21+08:00">2025-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Graphics/" itemprop="url" rel="index"><span itemprop="name">Graphics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2025/08/14/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%A7%88/p2.png" title="渲染图元"> <br></p>
<h1 id="CPU-GPU工作流程"><a href="#CPU-GPU工作流程" class="headerlink" title="CPU + GPU工作流程"></a>CPU + GPU工作流程</h1><ol>
<li>剔除，把一些不想看到的，或者看不到的东西排除掉</li>
<li>确定物体的先后渲染顺序</li>
<li>将对应的模型数据、材质等打包发送给GPU</li>
<li>发送SetPassCall和Drawcall告诉GPU渲染管线渲染模型数据所需的shader</li>
<li>数据在GPU渲染管线中绘制，将3D物体渲染为2D图像</li>
<li>将渲染图像存放在帧缓冲区（FrameBuffer）中。可以理解为一个和屏幕大小等大的临时画布</li>
<li>后处理操作。通过CPU拿到帧缓冲区的图像，调用shader再进入GPU渲染管线，对帧缓冲区的图像进行二次的修改，比如调色、bloom等操作</li>
<li>显示在屏幕上</li>
</ol>
<p>CPU应用程序端逻辑：经过剔除、排序等等，将模型数据打包发给GPU渲染管线<br>GPU渲染管线：拿到模型数据后，讲图像画出来，存放在对应的帧缓冲区中</p>
<p><img src="/2025/08/14/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%A7%88/p3.png" title="CPU打包数据"> <br></p>
<h1 id="GPU渲染管线"><a href="#GPU渲染管线" class="headerlink" title="GPU渲染管线"></a>GPU渲染管线</h1><ol start="0">
<li>CPU打包数据：vertex buffer&#x2F;index buffer&#x2F;frustum视锥&#x2F;directional light平行光&#x2F;texture+shader<br> • SetPass Call：设定好渲染设置后，告诉GPU使用哪个shader，使用哪种混合模式、设置背面剔除等等，当使用不同的材质或者相同的材质下不同的Pass时需要设置切换多个渲染状态，就会增加SetPassCall，所以SetPassCall的次数也能反映性能<br> • Draw Call（绘制调用）：CPU打包数据发送给GPU，告诉GPU使用哪些模型数据进行渲染</li>
<li>Vertex Shader: 使用顶点&#x2F;视锥信息将模型空间变换到屏幕空间</li>
<li>Triangle Processing 图元装配：把顶点信息按照缓存连接成三角形图元</li>
<li>Rasterization：插值计算出三角形每个像素的深度&#x2F;颜色</li>
<li>Pixel Shader (i.e. Fragment Shader)：根据灯光&#x2F;纹理贴图采样</li>
<li>Frame Buffer：post processing 抗锯齿 校色 景深（DOF） 动态模糊</li>
</ol>
<p><img src="/2025/08/14/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%A7%88/p1.jpg" title="全览图"> <br></p>
<h1 id="图元-vs-片元"><a href="#图元-vs-片元" class="headerlink" title="图元 vs 片元"></a>图元 vs 片元</h1><ul>
<li>图元</li>
</ul>
<p>渲染图元（rendering primitives）为图形渲染开发接口中用来描述各种图形元素的图形数据，所对应的就是绘图界面上看得见的实体，它包括了渲染所需的几何信息，可以是顶点数据、线段、多边形等。</p>
<p><img src="/2025/08/14/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%A7%88/p4.png" title="图元的数据类型"> <br></p>
<p>图元至少要包含一个顶点（Vertex）；一个顶点定义了2D或3D坐标系中一个点，也同样定义了若干个可以影响如何把顶点渲染到屏幕上的属性，如：</p>
<p><img src="/2025/08/14/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%A7%88/p5.png" title="图元顶点所包含的信息"> <br></p>
<ul>
<li>片元</li>
</ul>
<p>在GPU流水线中的三角形遍历阶段，将会检查每个像素是否被一个三角网格所覆盖；如果被覆盖的话，就会生成一个片元（fragment）；需要注意的是，一个片元并不是真正意义上的像素，而是包括了很多状态的集合，这些状态用于计算每个像素的最终颜色；这些状态包括了（但不限于）它的屏幕坐标、深度信息，以及其它从几何阶段输出的顶点信息，例如法线、纹理坐标等。</p>
<hr>
<h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lel18570471704/article/details/134708949">https://blog.csdn.net/lel18570471704/article/details/134708949</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/667522425">https://zhuanlan.zhihu.com/p/667522425</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/407046161">https://zhuanlan.zhihu.com/p/407046161</a><br>图元vs片元：<a target="_blank" rel="noopener" href="https://blog.csdn.net/DoomGT/article/details/115806364">https://blog.csdn.net/DoomGT/article/details/115806364</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/08/08/%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/08/%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/" class="post-title-link" itemprop="url">变换矩阵</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-08 11:42:32 / Modified: 15:25:06" itemprop="dateCreated datePublished" datetime="2025-08-08T11:42:32+08:00">2025-08-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>固定坐标系下，一个对象的变换等价于固定对象所处的坐标系变换。</p>
<p><img src="/2025/08/08/%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/p1.png" title="标量"> <br></p>
<p>经过线性变换(直线依旧是直线，保持网格线平等且等距分布，并且原点保持固定)：</p>
<p><img src="/2025/08/08/%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/p2.png" title="标量变换"> <br></p>
<p>如图，新坐标系的基就是那个绿箭头和红箭头，在原来的ij坐标系下的坐标值是[1,-2]和[3,0]。经过如图的计算过程，坐标系的变化，导致原来的V向量变成了[5,2]，实现了移动。</p>
<h1 id="Transformation-Matrix"><a href="#Transformation-Matrix" class="headerlink" title="Transformation Matrix"></a>Transformation Matrix</h1><p>常见的变换矩阵类型：<br><img src="/2025/08/08/%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/p3.png" title="变换矩阵举例"> <br></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Haotian Luo"
      src="/images/exciting-usagi.gif">
  <p class="site-author-name" itemprop="name">Haotian Luo</p>
  <div class="site-description" itemprop="description"><font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/miaopasss" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;miaopasss" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hubery.luo@icloud.com" title="E-Mail → mailto:hubery.luo@icloud.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Haotian Luo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://miaopasss.github.io/',]
      });
      });
  </script>

</body>
</html>
