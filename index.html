<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"miaopasss.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="赤团开时斜飞去， 最不安神晴又复雨。">
<meta property="og:type" content="website">
<meta property="og:title" content="乌啦呀哈呀哈乌啦！">
<meta property="og:url" content="https://miaopasss.github.io/index.html">
<meta property="og:site_name" content="乌啦呀哈呀哈乌啦！">
<meta property="og:description" content="赤团开时斜飞去， 最不安神晴又复雨。">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Haotian Luo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://miaopasss.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>乌啦呀哈呀哈乌啦！</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">乌啦呀哈呀哈乌啦！</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临，这里是喵pass的个人博客，希望有能帮到你的地方
</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页 | Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类 | Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签 | Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档 | Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/miaopasss" class="github-corner" title="Check out my GitHub" aria-label="Check out my GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/02/27/OpenGL%E9%A1%B6%E7%82%B9%E7%BB%98%E5%88%B6%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/27/OpenGL%E9%A1%B6%E7%82%B9%E7%BB%98%E5%88%B6%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">OpenGL顶点绘制数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-27 11:30:52" itemprop="dateCreated datePublished" datetime="2025-02-27T11:30:52+08:00">2025-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-28 17:41:30" itemprop="dateModified" datetime="2025-02-28T17:41:30+08:00">2025-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%B2%E6%9F%93/" itemprop="url" rel="index"><span itemprop="name">渲染</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>VAO（vertex-array object）顶点数组对象，用来管理VBO。</li>
<li>VBO（vertex buffer object）顶点缓冲对象，用来缓存用户传入的顶点数据。</li>
<li>EBO（element buffer object）索引缓冲对象，用来存放顶点索引数据。</li>
</ul>
<p>A VAO is an array of VBOs</p>
<p><img src="/2025/02/27/OpenGL%E9%A1%B6%E7%82%B9%E7%BB%98%E5%88%B6%E6%95%B0%E6%8D%AE/VAO.png" title="VAO和VBO之间的关系"> <br></p>
<h1 id="一、什么是OpenGL"><a href="#一、什么是OpenGL" class="headerlink" title="一、什么是OpenGL"></a>一、什么是OpenGL</h1><p>OpenGL是一套方便于用户使用的规范，而其本身包含了调用不同厂商直接在GPU中写好的程序接口，那些接口完成所有的功能实现，如完成2D、3D矢量图形渲染等功能（跨语言，跨平台）。</p>
<p>OpenGL by itself is not an API, but merely a specification. The OpenGL specification specifies exactly what the result&#x2F;output of each function should be and how it should perform. It is then up to the developers implementing this specification to come up with a solution of how this function should operate.<br>The people developing the actual OpenGL libraries are usually the graphics card manufacturers. Each graphics card that you buy supports specific versions of OpenGL which are the versions of OpenGL developed specifically for that card (series).</p>
<h2 id="OpenGL-vs-OpenCL"><a href="#OpenGL-vs-OpenCL" class="headerlink" title="OpenGL vs OpenCL"></a>OpenGL vs OpenCL</h2><ol>
<li>总体来说，OpenGL 主要做图形渲染，OpenCL 主要用 GPU 做通用计算。图形渲染的主要特点是 渲染管线基本单元，如光栅化、深度测试、模板测试、混合等等的实现。</li>
<li>OpenGL 可以用 Compute Shader 实现 OpenCL 同样的功能，但一般厂商对 Compute Shader 中低精度计算的支持（fp16 &#x2F; int8 等）不如 OpenCL ，性能会差一些</li>
<li>基于 OpenCL 编程可以自己实现 OpenGL 中的渲染操作，但由于没有图形接口，实现渲染管线基本单元效率较低。</li>
<li>OpenCL 和 OpenGL 最终实现都是往 GPU 发 Command Buffer ，不会互相影响，最多就是互相抢GPU计算资源。但如果有数据依赖关系，因为管线不同，两者是需要做额外同步的。</li>
</ol>
<p>opengl里叫drawcall，opencl里叫enqueue，vulkan里叫commandbuffer，虽然叫法不一样，但目的都是把指令从CPU发到GPU上运算。</p>
<p>cuda其实就是把kernel代码和c代码混合到一起写而已，最终也要把数据发到GPU去算，属于编译器支持的隐式发送。就好比写c&#x2F;c++调其他库api的时候，可以配置好库lib或者so位置，包个头文件就直接用，也可以自己动态加载对应库API一样。</p>
<h2 id="OpenGL渲染过程"><a href="#OpenGL渲染过程" class="headerlink" title="OpenGL渲染过程"></a>OpenGL渲染过程</h2><p>因为c++写的程序都是在cpu上运行的，但是OpenGL的接口是在GPU上运行的，而且OpenGL并不能凭空做程序中的数据或者是取代一些程序上的事，它是一种状态机，程序从cpu发数据到缓冲区并且告诉GPU你从哪一块缓冲区取数据画什么，然后提前设计好的着色器开始根据数据画图最后显示在显示器上。</p>
<p>画图渲染的顺序如下：</p>
<ol>
<li>声明一个缓冲区</li>
<li>声明之后需要绑定，因为在GPU中的缓冲区都是有编号的，或者说是有管理的</li>
<li>现在要给一个缓冲区塞数据，每个接口函数都可以通过说明文档来查看参数的意义和使用</li>
<li>我们需要告诉着色器我们的数据是怎么样的， 或者说是怎么处理这些数据</li>
</ol>
<h2 id="glVertexAttribPointer函数"><a href="#glVertexAttribPointer函数" class="headerlink" title="glVertexAttribPointer函数"></a>glVertexAttribPointer函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glVertexAttribPointer</span><span class="params">(GLuint index, GLint size, GLenum type,</span></span></span><br><span class="line"><span class="params"><span class="function">    GLboolean normalized, GLsizei stride, <span class="type">const</span> GLvoid * pointer)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/02/27/OpenGL%E9%A1%B6%E7%82%B9%E7%BB%98%E5%88%B6%E6%95%B0%E6%8D%AE/glVertexAttribPointer.png" title="glVertexAttribPointer函数参数解释"></p>
<p>人话就是：</p>
<p>index：我们从第几个顶点开始访问<br>size：一个顶点属性值里面有几个数值<br>type：每个值的数据类型<br>normalized：是否要转化为统一的值<br>stride：步幅 每个顶点属性值的大小，就是到下一个顶点的开始的字节偏移量。<br>pointer：在开始访问到顶点属性值的时候开始的指针位置（注意和Index的区别）<br>其实你就是把顶点属性值想象成结构体就行了，然后多个结构体一起存，和网络传输一样，我发送给了另一边需要解析网络包，是不是需要找我结构体开始的位置，然后一个结构体的大小，然后结构体对齐里面有什么，分别解析，还有步幅指针，我还可以跳过结构体，是一样的道理。</p>
<h1 id="二、VBO"><a href="#二、VBO" class="headerlink" title="二、VBO"></a>二、VBO</h1><h2 id="glVertex"><a href="#glVertex" class="headerlink" title="glVertex"></a>glVertex</h2><p>最原始的设置顶点方法，在glBegin和glEnd之间使用。OpenGL3.0已经废弃此方法。每个glVertex与GPU进行一次通信，十分低效。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBegin</span>(GL_TRIANGLES);</span><br><span class="line">    <span class="built_in">glVertex</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertex</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">glVertex</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br></pre></td></tr></table></figure>

<h2 id="顶点数组-Vertex-Array"><a href="#顶点数组-Vertex-Array" class="headerlink" title="顶点数组 Vertex Array"></a>顶点数组 Vertex Array</h2><p>顶点数组也是收集好所有的顶点，一次性发送给GPU。不过数据不是存储于GPU中的，绘制速度上没有显示列表快，优点是可以修改数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEDIUM_STARS 40</span></span><br><span class="line">M3DVector2f vMediumStars[MEDIUM_STARS];</span><br><span class="line"><span class="comment">//在这做点vMediumStars的设置//</span></span><br><span class="line"><span class="built_in">glVertexPointer</span>(<span class="number">2</span>, GL_FLOAT, <span class="number">0</span>, vMediumStars);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_POINTS, <span class="number">0</span>, MEDIUM_STARS);</span><br></pre></td></tr></table></figure>

<h2 id="VBO-顶点缓冲对象"><a href="#VBO-顶点缓冲对象" class="headerlink" title="VBO 顶点缓冲对象"></a>VBO 顶点缓冲对象</h2><p>VBO，全称为Vertex Buffer Object，与FBO，PBO并称，但它实际上老不少。就某种意义来说，他就是VA（Vertex Array）的升级版。VBO出现的背景是人们发现VA和显示列表还有让人不满足的地方。一般，在OpenGL里，提高顶点绘制的办法：</p>
<p>(1)显示列表：把常规的glBegin()-glEnd()中的代码放到一个显示列表中（通常在初始化阶段完成），然后每遍渲染都调用这个显示列表。<br>(2)VA：使用顶点数组，把顶点以及顶点属性数据作为数组，渲染的时候直接用一个或几个函数调动这些数组里的数据进行绘制，形式上是减少函数调用的次数（告别glVertex），提高绘制效率。</p>
<p>但是，这两种方法都有缺点。VA是在客户端设置的，所以执行这类函数（glDrawArray或glDrawElement）后，客户端还得把得到的顶点数据向服务端传输一次（所谓的“二次处理”），这样一来就有了不必要的动作了，降低了效率——如果我们写的函数能直接把顶点数据发送给服务端就好了——这正是VBO的特性之一。显示列表的缺点在于它的古板，一旦设定就不容许修改，所以它只适合对一些“固定”的东西的绘制进行包装。（我们无办法直接在硬件层改顶点数据，因为这是脱离了流水线的事物）。<br>而VBO直接把顶点数据交到流水线的第一步，与显示列表的效率还是有差距，但它这样就得到了操作数据的弹性——渲染阶段，我们的VBO绘制函数持续把顶点数据交给流水线，在某一刻我们可以把该帧到达了流水线的顶点数据取回客户端修改(Vertex mapping)，再提交回流水线(Vertex unmapping)，或者用 glBufferData&#x2F;glBufferSubData 重新全部或buffer提交修改了的顶点数据，这是VBO的另一个特性。</p>
<p>VBO结合了VA和显示列表这个说法不太妥当，应该说它结合了两者的一些特性，绘制效率在两者之间，且拥有良好的数据更改弹性。这种折衷造就了它一直为目前最高的地位。</p>
<p>当我们在顶点着色器中把顶点传送到GPU中的时候，不能每个顶点数据传送一次，因为太耗时而且造成资源浪费，所以就要用到缓冲对象，我们把大量的数据存储在GPU内存上，然后一次传输大量数据到显卡上，顶点缓冲对象就是帮助我们来管理GPU内存的。</p>
<h2 id="顶点缓冲流程"><a href="#顶点缓冲流程" class="headerlink" title="顶点缓冲流程"></a>顶点缓冲流程</h2><p>首先我们需要使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据，一定要使用该函数来配置各个属性的数据，因为顶点数据不只包含位置，还可能会包含顶点颜色、顶点法线等等，那一个顶点数据是如何被OpenGL解析然后放入到顶点着色器的各个属性中，就需要通过该函数进行准确的配置。<br>每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVetexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的，因为同一个类型的缓冲区同时最多绑定一个目标缓冲。</p>
<h1 id="三、VAO"><a href="#三、VAO" class="headerlink" title="三、VAO"></a>三、VAO</h1><h2 id="VAO-顶点数组对象"><a href="#VAO-顶点数组对象" class="headerlink" title="VAO 顶点数组对象"></a>VAO 顶点数组对象</h2><p>VAO并不是必须的，VBO可以独立使用，VBO缓存了数据，而数据的使用 方式（glVertexAttribPointer 指定的数据宽度等信息）并没有缓存，VBO将顶点信息放到GPU中，GPU在渲染时去缓存中取数据，二者中间的桥梁是GL-Context。GL-Context整个程序一般只有一个，所以如果一个渲染流程里有两份不同的绘制代码，当切换VBO时（有多个VBO时，通过glBindBuffer切换 ），数据使用方式信息就丢失了。而GL-context就负责在他们之间进行切换。这也是为什么要在渲染过程中，在每份绘制代码之中会有glBindbuffer、glEnableVertexAttribArray、glVertexAttribPointer。VAO记录该次绘制所需要的所有VBO所需信息，把它保存到VBO特定位置，绘制的时候直接在这个位置取信息绘制。　</p>
<p>VAO的全名是Vertex Array Object，首先，它不是Buffer-Object，所以不用作存储数据；其次，它针对“顶点”而言，也就是说它跟“顶点的绘制”息息相关。我们每一次绘制的时候，都需要绑定缓冲对象以此来拿到顶点数据，都需要去配置顶点属性指针以便OpenGL知道如何来解析顶点数据，这是相当麻烦的，对一个多边形而言，它每次的配置都是相同的，如何来存储这个相同的配置呢。<br>VAO为我们解决了这个大麻烦，当配置顶点属性数据的时候，只需要将配置函数调用执行一次，随后再绘制该物体的时候就只需要绑定相应的VAO即可，这样，我们就可以通过绑定不同的VAO（提醒，与VBO一样，同一时刻只能绑定一个VAO），使得在不同的顶点数据和属性配置切换变得非常简单。VAO记录的是一次绘制中所需要的信息，这包括“数据在哪里glBindBuffer”、“数据的格式是怎么样的glVertexAttribPointer”、shader-attribute的location的启用glEnableVertexAttribArray。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br></pre></td></tr></table></figure>

<p>VAO的使用非常简单，要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，配置完以后，VAO中就存储了我们想要的各种数据，之后解绑VAO供之后使用，再次使用需要我们再次绑定。</p>
<p>注意：glVertexAttribPointer()这个函数会自动从当前绑定的VBO里获取顶点数据，所以在第一节VBO里如果想要使用正确的顶点数据，每次都要绑定相应的VBO，但是现在，我们在绑定VBO之前绑定了VAO，那么glEnableVertexAttribPointer()所进行的配置就会保存在VAO中。我们可以通过不同的配置从一个VBO内拿到不同的数据放入不同的VAO中，这样VAO中就有了我们所需要的数据，它根据顶点配置到VBO中索取到数据，之后直接绑定相应的VAO即可，glDrawArrays()函数就是需要从VAO中拿到数据进行绘制。但是要明白的是，我们是通过VAO来间接绑定VBO的，实际上数据还是要存储在VBO中的，VAO内并没有存储顶点的数据，如果我们要绘制两个不同的三角形，我们可能需要定义两个VBO，每个VBO内有三个顶点数据。</p>
<hr>
<h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h1><p>OpenGL: <a target="_blank" rel="noopener" href="https://learnopengl.com/Getting-started/OpenGL">https://learnopengl.com/Getting-started/OpenGL</a><br>VAO和VBO: <a target="_blank" rel="noopener" href="https://blog.csdn.net/p942005405/article/details/103770259">https://blog.csdn.net/p942005405/article/details/103770259</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/02/25/Mono-vs-IL2CPP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/25/Mono-vs-IL2CPP/" class="post-title-link" itemprop="url">Mono vs. IL2CPP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-25 17:50:04" itemprop="dateCreated datePublished" datetime="2025-02-25T17:50:04+08:00">2025-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-28 15:54:31" itemprop="dateModified" datetime="2025-02-28T15:54:31+08:00">2025-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">C#编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Common-Language-Runtime"><a href="#Common-Language-Runtime" class="headerlink" title="Common Language Runtime"></a>Common Language Runtime</h1><p>公共语言运行时</p>
<p>VM和LR其实比较类似，有人说LR的创建就是为了对标VM。简单来说，就是一个程序运行所需要的环境，包括各种资源、各种操作等等。不同语言、不同操作系统所需要的运行时环境都不一样。举个例子，Windows上的可执行程序都被包装成了.exe格式，而这种.exe格式文件提供了一个程序从加载到运行所需要的所有资源和环境。</p>
<p>而CLR提供了：</p>
<ol>
<li>一个支持GC的虚拟机，该虚拟机有自己的一套指令集，即CIL（公共中间语言，COmmon Intermediate Language）。高级语言最终会转化成CIL，</li>
<li>一种丰富的元数据表示，用来描述数据类型、字段、方法等。通过这些统一的描述方法来生成对应的程序。</li>
<li>一种文件格式，一种专属的不于操作系统和硬件绑定的格式，即跨平台。</li>
<li>一套类库，提供了垃圾回收、异常、泛型等基本功能，提供了字符串、数组、列表、字典等数据结构，提供了文件、网络、交互等操作系统功能。</li>
<li>一系列规则，定制了在运行时如果查找引用其他文件、生命周期等一系列规则。</li>
</ol>
<p><img src="/2025/02/25/Mono-vs-IL2CPP/CLR.png" title="高级语言、CLR与CIL之间的关系"> <br></p>
<h2 id="Common-Language-Specification"><a href="#Common-Language-Specification" class="headerlink" title="Common Language Specification"></a>Common Language Specification</h2><p>CLR最大的优势就在于跨语言跨平台支持。目前微软已经为多种语言开发旅了基于CLR的编译器，包括C++、C#、Visual Basic、F#、Iron Python、 Iron Ruby和IL。还有一些大学、公司和机构为一些语言也开发了基于CLR的编译器，包括da、APL、Caml、COBOL、Eiffel、Forth、Fortran、Haskell、Lexicon、LISP、LOGO、Lua、Mercury、ML、Mondrian、Oberon、Pascal、Perl、PHP、Prolog、RPG、Scheme、Smaltak、Tcl&#x2F;Tk等。<br>CLR为不同的编程语言提供了统一的运行平台，对于开发者来说，他们无需考虑平台运行问题，无论使用什么语言开发，最终都会编译成IL，供CLR运行。对于CLR来说，它并不知道也无需知道IL是从什么语言编译过来的。</p>
<p>但是这么多种各式各样的语言最终都要编译成IL，肯定需要一种规范，CLS就是用来规范语言的。CLS全称Common Language Specification，即公共语言规范。也就是说所有被CLR支持的高级语言都需要最少支持CLS所规定的功能集。只要高级语言最少支持了CLS之后，其它附加功能&#x2F;特性可自行实现。</p>
<h2 id="Managed-Code"><a href="#Managed-Code" class="headerlink" title="Managed Code"></a>Managed Code</h2><p>C#中的托管代码是指由.NET运行时环境（CLR）管理和执行的代码。当我们使用C#编写的代码被编译后，它会被转换成中间语言（IL）代码，也称为托管代码。托管代码在运行时由CLR加载和执行，CLR负责内存管理、垃圾回收、安全性等任务，开发者无需过度关注资源的释放。其实可以从字面上理解，托管代码委托给CLR进行管理，开发者不管。<br>而至于非托管代码是指不受CLR管理的代码，通常是使用其他编程语言（如C++）编写的代码，比如操作系统代码、C#中的Socket、Stream等，这些代码无法通过CLR的GC完全释放占用的资源。一般来说，非托管的功能都被包装过了，比如当我们访问文件的时候，肯定不会直接使用操作系统的CreateFile函数，而是使用System.IO.File类。</p>
<p>托管代码具有以下特点：<br>自动内存管理：CLR负责分配和释放内存，开发人员无需手动管理内存。<br>垃圾回收：CLR会自动检测和回收不再使用的对象，减少内存泄漏的风险。<br>安全性：CLR提供了安全性机制，确保代码的执行不会对系统造成损害。<br>跨平台：托管代码可以在不同的操作系统上运行，只要有对应的CLR。</p>
<p>相对应的，非托管代码直接操作计算机的硬件和操作系统资源，需要手动管理内存和资源的分配和释放。非托管代码在性能方面可能更高效，但也更容易出现内存泄漏和安全问题。C#可以通过使用InteropServices命名空间中的功能与非托管代码进行交互，这样可以在C#中调用非托管代码的功能。</p>
<h2 id="FCL"><a href="#FCL" class="headerlink" title="FCL"></a>FCL</h2><p>The Framework Class Library or FCL provides the system functionality in the .NET Framework as it has various classes, data types, interfaces, etc. to build different types of applications including desktop applications, web applications, mobile applications. The Framework Class Library is integrated with the Common Language Runtime (CLR) and is used by all the .NET languages such as C#, F#, Visual Basic .NET, etc. </p>
<h3 id="BCL-vs-FCL"><a href="#BCL-vs-FCL" class="headerlink" title="BCL vs. FCL"></a>BCL vs. FCL</h3><ul>
<li>The Base Class Library (BCL) is literally that, the base. It contains basic, fundamental types like System.String and System.DateTime.</li>
<li>The Framework Class Library (FCL) is the wider library that contains the totality: ASP.NET（web application framework 对标 Node.js）, WinForms, the XML stack, ADO.NET and more. You could say that the FCL includes the BCL.</li>
</ul>
<h1 id="C-Compilers"><a href="#C-Compilers" class="headerlink" title="C# Compilers"></a>C# Compilers</h1><p>C#源文件通过编译器（如CSC.exe）编译成中间语言（IL）和元数据，生成.exe或.dll文件。IL是一种伪代码，独立于任何CPU，可以在任何装有.Net Framework的机器上运行‌</p>
<p>Common Intermediate Language (CIL), formerly called Microsoft Intermediate Language (MSIL) or Intermediate Language (IL) is the intermediate language binary instruction set defined within the Common Language Infrastructure (CLI) specification. CIL instructions are executed by a CIL-compatible runtime environment such as the Common Language Runtime. Languages which target the CLI compile to CIL. CIL is object-oriented, stack-based bytecode. Runtimes typically just-in-time compile CIL instructions into native code.</p>
<ul>
<li><strong>Just In Time compiler</strong><br>即时编译。当程序运行时，IL通过CLR中的即时编译器(JIT)将CIL的byte code编译为目标平台的原生码(针对特定CPU的机械码)。JIT编译是在程序运行时进行的，确保了代码的可移植性和执行效率‌程序运行过程中。</li>
<li><strong>Ahead Of Time compiler</strong><br>提前编译。程序运行之前，提前编译器(AOT)将C#源码直接编译为目标平台的原生码并且存储。这种方式通常用于生成本地应用程序，提高启动速度和性能‌。</li>
</ul>
<p>将.exe或.dll文件中的CIL的byte code</p>
<h2 id="Unity-compiler"><a href="#Unity-compiler" class="headerlink" title="Unity compiler"></a>Unity compiler</h2><p>Unity编译C#脚本的过程通常是自动进行的，当你在Unity编辑器中构建项目时（比如导出为执行文件或者打包为Android&#x2F;iOS应用），Unity会编译所有C#脚本。<br>如果你需要在Unity编辑器外部编译C#代码，你可以使用Mono的mcs编译器或者.NET Core SDK。</p>
<p>以下是使用mcs编译器的基本命令行示例：</p>
<blockquote>
<p>mcs -out:YourGame.exe -recurse:*.cs</p>
</blockquote>
<h1 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h1><p>Mono, the open source development platform based on the .NET Framework, helps developers to build cross-platform applications. Mono’s .NET implementation is based on the ECMA standards for C# and the Common Language Infrastructure. Mono was originally reimplementation of the .NET for linux. Today is much more.</p>
<h2 id="Unity-Mono"><a href="#Unity-Mono" class="headerlink" title="Unity Mono"></a>Unity Mono</h2><p>The Mono scripting backend compiles code at runtime, with a technique called just-in-time compilation (JIT). Unity uses a fork of the open source Mono project.<br>Some platforms don’t support JIT compilation, so the Mono backend doesn’t work on every platform. Other platforms support JIT and Mono but not ahead-of-time compilation (AOT), and so can’t support the IL2CPP backend. When a platform can support both backends, Mono is the default.</p>
<h1 id="IL2CPP"><a href="#IL2CPP" class="headerlink" title="IL2CPP"></a>IL2CPP</h1><p>The IL2CPP backend converts MSIL (Microsoft Intermediate Language) code (for example, C# code in scripts) into C++ code, then uses the C++ code to create a native binary file (for example, .exe, .apk, or .xap) for your chosen platform. This type of compilation, in which Unity compiles code specifically for a target platform when it builds the native binary, is called ahead-of-time (AOT) compilation.</p>
<h2 id="How-IL2CPP-works"><a href="#How-IL2CPP-works" class="headerlink" title="How IL2CPP works"></a>How IL2CPP works</h2><ol>
<li>The Roslyn C# compiler compiles your application’s C# code and any required package code to .NET DLLs (managed assemblies).</li>
<li>Unity applies managed bytecode stripping（代码裁剪）. This step can significantly reduce the size of a built application.</li>
<li>The IL2CPP backend converts all managed assemblies into standard C++ code.</li>
<li>The C++ compiler compiles the generated C++ code and the runtime part of IL2CPP with a native platform compiler.</li>
<li>Unity creates either an executable file or a DLL, depending on the platform you target.</li>
</ol>
<h1 id="Mono-vs-IL2CPP-on-Unity"><a href="#Mono-vs-IL2CPP-on-Unity" class="headerlink" title="Mono vs. IL2CPP on Unity"></a>Mono vs. IL2CPP on Unity</h1><p>Unity中C#代码的处理过程</p>
<ol>
<li><p>编写C#代码：<br>开发者在Unity编辑器中编写C#脚本，这些脚本通常用于实现游戏逻辑、控制角色行为、处理用户输入等。</p>
</li>
<li><p>编译C#代码：<br>当开发者在Unity中保存C#脚本时，Unity会自动触发编译过程。Unity使用Mono或IL2CPP作为其脚本引擎。<br>Mono：在使用Mono时，Unity会将C#代码编译成CIL（Common Intermediate Language）。这个过程是在Unity编辑器中完成的，生成的CIL代码会被打包到Unity的可执行文件中。<br>IL2CPP：如果选择使用IL2CPP，Unity会将C#代码首先编译为CIL，然后将CIL代码转换为C++代码，最后再编译为本地机器代码。IL2CPP的主要优点是可以提高性能和安全性。</p>
</li>
<li><p>生成的CIL代码：<br>生成的CIL代码会被打包到Unity的可执行文件中，通常是一个DLL文件。这个DLL文件包含了所有的游戏逻辑和功能。</p>
</li>
<li><p>构建过程：<br>在构建游戏时，Unity会将所有的资源（如纹理、模型、音频等）和编译后的CIL代码打包成一个可执行文件（如EXE、APK、IPA等），具体取决于目标平台。<br>Unity的构建系统会处理所有的依赖关系，确保所有需要的资源和代码都包含在最终的构建中。</p>
</li>
<li><p>运行时执行：<br>当用户运行构建的游戏时，Unity的运行时环境会加载可执行文件。<br>如果使用Mono，运行时会在需要时将CIL代码即时编译为本地机器代码（JIT编译）。如果使用IL2CPP，CIL代码已经在构建时转换为本地机器代码，因此可以直接执行。<br>运行时会管理内存、处理输入、渲染图形等，确保游戏的正常运行。</p>
</li>
<li><p>总结<br>在Unity中，开发者编写的C#代码会经过编译过程，生成CIL代码，并在构建时打包到可执行文件中。Unity使用Mono或IL2CPP作为脚本引擎，分别通过JIT编译或AOT编译将CIL代码转换为本地机器代码。这个过程使得Unity能够在不同平台上运行相同的代码，同时也为开发者提供了灵活的开发环境。</p>
</li>
</ol>
<h2 id="Cross-platform"><a href="#Cross-platform" class="headerlink" title="Cross-platform"></a>Cross-platform</h2><p>Mono运行时编译器支持将IL代码转为对应平台原生码<br>IL可以在任何支持CLI，通用语言环境的平台上运行，IL的运行是依托于Mono运行时。</p>
<h2 id="IOS-Platform"><a href="#IOS-Platform" class="headerlink" title="IOS Platform"></a>IOS Platform</h2><p>IOS不支持动态生成的代码具有执行权限，而通常jit就是运行过程中动态编译代码为机器码并缓存&#x2F;执行（Mono运行时将IL编译成机械码），即封存了内存的可执行权限，变相的封锁了jit编译方式</p>
<hr>
<h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h1><p>CLR简介：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42186870/article/details/119621977/">https://blog.csdn.net/weixin_42186870/article/details/119621977/</a><br>Mono简介：<a target="_blank" rel="noopener" href="https://www.mono-project.com/docs/about-mono/">https://www.mono-project.com/docs/about-mono/</a><br>IL2CPP简介：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/6000.0/Documentation/Manual/scripting-backends-il2cpp.html">https://docs.unity3d.com/6000.0/Documentation/Manual/scripting-backends-il2cpp.html</a><br>IOS平台代码热更：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33060405/article/details/144314440">https://blog.csdn.net/qq_33060405/article/details/144314440</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/02/24/CNAME%E5%92%8C%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/24/CNAME%E5%92%8C%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">CNAME和域名解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-24 13:34:05" itemprop="dateCreated datePublished" datetime="2025-02-24T13:34:05+08:00">2025-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-27 14:51:26" itemprop="dateModified" datetime="2025-02-27T14:51:26+08:00">2025-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="域名解析协议-Domain-Name-System"><a href="#域名解析协议-Domain-Name-System" class="headerlink" title="域名解析协议 Domain Name System"></a>域名解析协议 Domain Name System</h1><ol>
<li>DNS让用户能够通过域名访问网页(<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> -&gt; 36.152.44.95)</li>
<li>计算机会先将域名发送到一个解析域名的服务器上<br> 2.1. 在网络上有很多服务器，能解析各种各样的域名，比如有专门解析.org的，解析.com的，解析.net的。等等，最主要的有一个根域名服务器(Root Name Server)<br> 2.2. 域名解析(在服务器上查找IP地址)的过程有两种算法，迭代查询，递归查询。一般是两种查询的结合<br> 2.3. 本机计算机找到其中一台解析域名的服务器(可能是.com)，如果没有找到对应的IP地址，那么就会去找根域名服务器，根域名服务器知道所有的子服务器，<br> 所以他肯定知道该域名所对应的IP地址在那个子服务器中，所以告诉第一次查询的服务器要他去另一台服务器上找，找到了，就将其返回给计算机，<br> 以后在有另一台计算机也通过这个域名访问，那么第一台服务器会有原来的域名IP地址的缓存，就不用去找根服务器了。<br> 2.4. 找到了，就能找到我们要访问的服务器了。</li>
</ol>
<hr>
<h1 id="根域名"><a href="#根域名" class="headerlink" title="根域名"></a>根域名</h1><p><img src="/2025/02/24/CNAME%E5%92%8C%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/RootDomain.jpg" alt="图片" title="域名结构"><br>Root Domain is the highest hierarchical level of a site and is separated from the Top Level Domain by a dot (e.g. rootdomain.com).</p>
<hr>
<h1 id="A-记录"><a href="#A-记录" class="headerlink" title="A 记录"></a>A 记录</h1><p>Address Record indicates the IP address of a given domain. For example, if you pull the DNS records of cloudflare.com, the A record currently returns an IP address of: 104.17.210.9. A records only hold IPv4 addresses. If a website has an IPv6 address, it will instead use an “AAAA” record.</p>
<p><img src="/2025/02/24/CNAME%E5%92%8C%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/ARecord.png" alt="图片" title="A记录组成部分"></p>
<p>The “@” symbol in this example indicates that this is a record for the root domain, and the “14400” value is the TTL (time to live), listed in seconds. The default TTL for A records is 14,400 seconds. This means that if an A record gets updated, it takes 240 minutes (14,400 seconds) to take effect.</p>
<hr>
<h1 id="内容分发网络"><a href="#内容分发网络" class="headerlink" title="内容分发网络"></a>内容分发网络</h1><p>内容分发网络 (CDN) 是一个分布在不同地理位置的服务器群，用于缓存靠近最终用户的内容。CDN 可以快速传输加载互联网内容所需的资产，包括 HTML 网页、JavaScript 文件、样式表、图像和视频。</p>
<hr>
<h1 id="CNAME-别名记录"><a href="#CNAME-别名记录" class="headerlink" title="CNAME 别名记录"></a>CNAME 别名记录</h1><p>CNAME记录，也叫别名记录，相当于给A记录中的域名起个小名儿，比如<a href="http://www.xx.com的小名儿就叫www.yy.com好了，然后CNAME记录也和A记录一样，是一种指向关系，把小名儿www.yy.com指向了www.xx.com，然后通过A记录，www.xx.com又指向了对应的IP：">www.xx.com的小名儿就叫www.yy.com好了，然后CNAME记录也和A记录一样，是一种指向关系，把小名儿www.yy.com指向了www.xx.com，然后通过A记录，www.xx.com又指向了对应的IP：</a></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://www.yy.com/">www.yy.com</a> → <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> → 1.1.1.1</p>
</blockquote>
<p>这样一来就能通过它的小名儿直接访问1.1.1.1了。</p>
<br>

<h2 id="多个域名指向同一个地址"><a href="#多个域名指向同一个地址" class="headerlink" title="多个域名指向同一个地址"></a>多个域名指向同一个地址</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.yy.com/">www.yy.com</a> → <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> → 1.1.1.1<br><a target="_blank" rel="noopener" href="http://www.cc.com/">www.cc.com</a> → <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> → 1.1.1.1<br><a target="_blank" rel="noopener" href="http://www.kk.com/">www.kk.com</a> → <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> → 1.1.1.1</p>
</blockquote>
<p>突然服务器的IP地址因为一些不可描述的原因要换了，不再是1.1.1.1了，换成了2.2.2.2，这时候你发现，只要把<a href="http://www.xx.com的指向修改一下即可：">www.xx.com的指向修改一下即可：</a></p>
<blockquote>
<p>域名 <a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> → 2.2.2.2<br>这时候你又发现了，原来他的小名儿不需要做更改，直接就能访问服务器，因为他们都只指向了<a target="_blank" rel="noopener" href="http://www.xx.com,服务器ip改没改它们不管./">www.xx.com，服务器IP改没改它们不管。</a></p>
</blockquote>
<p>那么假如不用CNAME，直接做A记录，那么当1.1.1.1更改的时候，全部相关A记录指向关系都要做更改</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://www.yy.com/">www.yy.com</a> → 1.1.1.1<br><a target="_blank" rel="noopener" href="http://www.cc.com/">www.cc.com</a> → 1.1.1.1<br><a target="_blank" rel="noopener" href="http://www.xx.com/">www.xx.com</a> → 1.1.1.1<br><a target="_blank" rel="noopener" href="http://www.kk.com/">www.kk.com</a> → 1.1.1.1</p>
</blockquote>
<br>

<h2 id="使用CDN"><a href="#使用CDN" class="headerlink" title="使用CDN"></a>使用CDN</h2><p>假如你是DD公司老板，你公司中的一台IP为1.1.1.1的服务器，注册了域名为<a target="_blank" rel="noopener" href="http://www.dd.com,要对外提供客户访问.随着公司越做越大,访问量也越来越多,服务器顶不住了,你去找cdn提供商购买cdn加速服务,这个时候他们要求你的域名做个cname指向他们给你的一个域名叫www.dd.cdn.com/">www.dd.com，要对外提供客户访问。随着公司越做越大，访问量也越来越多，服务器顶不住了，你去找CDN提供商购买CDN加速服务，这个时候他们要求你的域名做个CNAME指向他们给你的一个域名叫www.dd.cdn.com</a></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://www.dd.com/">www.dd.com</a> → <a target="_blank" rel="noopener" href="http://www.dd.cdn.com/">www.dd.cdn.com</a></p>
</blockquote>
<p>当用户访问<a href="http://www.dd.com的时候，本地DNS会获得CDN提供的CNAME域名：www.dd.cdn.com，然后再次向DNS调度系统发出请求，通过DNS调度系统的智能解析，把离客户端地理位置最近的（或者相对负载低的，主要看CDN那边智能解析的策略）CDN提供商的服务器IP返回给本地DNS，然后再由本地DNS回给客户端，让用户就近取到想要的资源（如访问网站），大大降低了延迟。">www.dd.com的时候，本地DNS会获得CDN提供的CNAME域名：www.dd.cdn.com，然后再次向DNS调度系统发出请求，通过DNS调度系统的智能解析，把离客户端地理位置最近的（或者相对负载低的，主要看CDN那边智能解析的策略）CDN提供商的服务器IP返回给本地DNS，然后再由本地DNS回给客户端，让用户就近取到想要的资源（如访问网站），大大降低了延迟。</a></p>
<p><img src="/2025/02/24/CNAME%E5%92%8C%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/CDN.png" alt="图片" title="使用CNAME配置使用CDN服务器"></p>
<hr>
<h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h1><p>域名解析：<a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/dns/what-is-dns/">https://www.cloudflare.com/learning/dns/what-is-dns/</a><br>CNAME别名记录：<a target="_blank" rel="noopener" href="https://blog.csdn.net/DD_orz/article/details/100034049">https://blog.csdn.net/DD_orz/article/details/100034049</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/02/14/%E7%9B%AE%E5%89%8D%E9%81%87%E5%88%B0%E7%9A%84%E6%89%80%E6%9C%89C-%E8%84%9A%E6%9C%AC%E5%AF%BC%E8%87%B4Unity%E5%8D%A1%E6%AD%BB-%E9%97%AA%E9%80%80%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/14/%E7%9B%AE%E5%89%8D%E9%81%87%E5%88%B0%E7%9A%84%E6%89%80%E6%9C%89C-%E8%84%9A%E6%9C%AC%E5%AF%BC%E8%87%B4Unity%E5%8D%A1%E6%AD%BB-%E9%97%AA%E9%80%80%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">目前遇到的所有C#脚本导致Unity卡死/闪退的bug</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-14 13:14:58" itemprop="dateCreated datePublished" datetime="2025-02-14T13:14:58+08:00">2025-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-27 14:51:37" itemprop="dateModified" datetime="2025-02-27T14:51:37+08:00">2025-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">C#编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Unity-2022-3-55f1"><a href="#Unity-2022-3-55f1" class="headerlink" title="Unity 2022.3.55f1"></a>Unity 2022.3.55f1</h1><hr>
<h2 id="问题：属性-Property-和访问器-Accessor"><a href="#问题：属性-Property-和访问器-Accessor" class="headerlink" title="问题：属性(Property)和访问器(Accessor)"></a>问题：属性(Property)和访问器(Accessor)</h2><p>如果在当前属性中直接添加自定义get和set访问器，在Unity引擎中访问&#x2F;修改此属性时游戏会闪退。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TestProperty &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> TestProperty;&#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            TestProperty = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>直接使用默认访问器</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StartPage</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TestProperty &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个新属性专门用于访问</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StartPage</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> testProperty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TestProperty &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> testProperty;&#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            testProperty = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题：Start函数中使用不当loop循环"><a href="#问题：Start函数中使用不当loop循环" class="headerlink" title="问题：Start函数中使用不当loop循环"></a>问题：Start函数中使用不当loop循环</h2><p>如果在start函数中使用while循环处理资源加载进度条，Unity引擎会在importing asset弹窗中卡死</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Progressbar loadingBar;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> AssetLabelReference gameImageAssets;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        AsyncOperationHandle asyncHandle = Addressables.LoadAssetsAsync&lt;Sprite&gt;(gameImageAssets, _ =&gt; &#123;&#125;);</span><br><span class="line">        asyncHandle.Completed += EnterGame;</span><br><span class="line">        StartCoroutine(GameLoadingCoroutine(asyncHandle));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">GameLoadingCoroutine</span>(<span class="params">AsyncOperationHandle handle</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// yield return Addressables.LoadAssetsAsync&lt;Sprite&gt;(gameImageAssets, _ =&gt; &#123;&#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!handle.IsDone &amp;&amp; handle.PercentComplete &lt; <span class="number">1f</span>)</span><br><span class="line">            loadingBar.SetProgressPercent(handle.PercentComplete);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EnterGame</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// Disable Loading bar</span></span><br><span class="line">        <span class="comment">// Enter gameplay</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用协程(Coroutine)将while操作与Unity生命周期同步</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Progressbar loadingBar;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> AssetLabelReference gameImageAssets;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        AsyncOperationHandle asyncHandle = Addressables.LoadAssetsAsync&lt;Sprite&gt;(gameImageAssets, _ =&gt; &#123;&#125;);</span><br><span class="line">        StartCoroutine(GameLoadingCoroutine(asyncHandle));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">GameLoadingCoroutine</span>(<span class="params">AsyncOperationHandle handle</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!handle.IsDone &amp;&amp; handle.PercentComplete &lt; <span class="number">1f</span>) &#123;</span><br><span class="line">            loadingBar.SetProgressPercent(handle.PercentComplete);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handle.Status == AsyncOperationStatus.Succeeded)</span><br><span class="line">            EnterGame();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Debug.LogError(<span class="string">$&quot;Failed to load game asset sprites: <span class="subst">&#123;handle.Status&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EnterGame</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// Disable Loading bar</span></span><br><span class="line">        <span class="comment">// Enter gameplay</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/02/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A5%97%E6%8E%A5%E5%AD%97-Socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A5%97%E6%8E%A5%E5%AD%97-Socket/" class="post-title-link" itemprop="url">网络编程与套接字(Socket)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-13 09:35:34" itemprop="dateCreated datePublished" datetime="2025-02-13T09:35:34+08:00">2025-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-27 14:51:40" itemprop="dateModified" datetime="2025-02-27T14:51:40+08:00">2025-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Socket-vs-Port"><a href="#Socket-vs-Port" class="headerlink" title="Socket vs Port"></a>Socket vs Port</h1><ul>
<li>A TCP socket is an endpoint instance defined by an IP address and a port in the context of either a particular TCP connection or the listening state.</li>
<li>A port is a virtualisation identifier defining a service endpoint (as distinct from a service instance endpoint aka session identifier).</li>
<li>A TCP socket is not a connection, it is the endpoint of a specific connection.</li>
<li>There can be concurrent connections to a service endpoint, because a connection is identified by both its local and remote endpoints, allowing traffic to be routed to a specific service instance.</li>
<li>There can only be one listener socket for a given address&#x2F;port combination.</li>
</ul>
<p>Specifically, a TCP socket consists of five things:</p>
<ol>
<li>transport layer protocol,</li>
<li>local address,</li>
<li>local port, </li>
<li>remote address, </li>
<li>remote port</li>
</ol>
<p>A port is a number between 1 and 65535 inclusive that signifies a logical gate in a device. Every connection between a client and server requires a unique socket.</p>
<p>For example:</p>
<ul>
<li><em>33123</em> is a port.</li>
<li><em>(localhost, 33123, 69.59.196.211, 80, TCP)</em> is a socket.</li>
</ul>
<blockquote>
<p>Firefox (localhost:33123) &lt;———–&gt; stackoverflow.com (69.59.196.211:80)<br>Chrome  (localhost:33124) &lt;———–&gt; stackoverflow.com (69.59.196.211:80)</p>
</blockquote>
<p>When a client device accesses a website (such as Chrome sending HTTP requests), it automatically connects to port 80 on the web server to retrieve the requested content. When the web server receives the answer, it sends a response that has 80 as source port and 33123 as destination port.</p>
<hr>
<h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h1><p>网络编程与套接字：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Sunbreaker/p/11318288.html">https://www.cnblogs.com/Sunbreaker/p/11318288.html</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/02/12/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E5%8F%91%E9%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/12/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E5%8F%91%E9%80%81/" class="post-title-link" itemprop="url">数据的封装与发送</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-12 17:46:00" itemprop="dateCreated datePublished" datetime="2025-02-12T17:46:00+08:00">2025-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-27 14:43:06" itemprop="dateModified" datetime="2025-02-27T14:43:06+08:00">2025-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="各层数据的组成形式"><a href="#各层数据的组成形式" class="headerlink" title="各层数据的组成形式"></a>各层数据的组成形式</h1><ul>
<li><p>数据单元（data unit）<br>指许多信息单元。常用的数据单元有服务数据单元（SDU）、协议数据单元（PDU）。SDU是在同一机器上的两层之间传送信息。PDU是发送机器上每层的信息发送到接收机器上的相应层（同等层间交流用的）。</p>
</li>
<li><p>分组&#x2F;分片<br>ip层的上层是传输层（tcp的头部为20Byte，udp头部字节是8Byte），ip层自己的头部需要占20字节，ip层的MTU &#x3D; 1500 - 20 &#x3D; 1480Byte, 超过1480Byte的数据，都需要被ip层分片，在达到目的前会自己重组</p>
<ul>
<li>tcp是可靠传输协议，通过超时与重传机制，来保证收到的数据是完整的。因为tcp是可靠传输协议，如果要传输的数据大于 1480 - 20(tcp头部) &#x3D;1460Byte时，在ip层被分片，而ip层分片会导致，如果其中的某一个分片丢失，因为tcp层不知道哪个ip数据片丢失，所以就需要重传整个数据段，这样就造成了很大空间和时间资源的浪费，为了解决这个问题，就有了tcp分组和MSS（最长报文大小）概念，利用tcp三次握手建立链接的过程，交互各自的MTU，然后用小的那个MTU-20-20 , 得到MSS，这样就避免在ip层被分片。</li>
<li>由于udp是不可靠传输的，所以ip分片主要是为了upd服务的，所以就有了网上的 1500 - 20(ip头部) - 8(udp头部) &gt; 1472Byte 的说法，把1472作为ip分片的标准</li>
</ul>
</li>
<li><p>报文(message) —— 应用层<br>报文是网络中交换与传输的数据单元，也是网络传输的单元。报文包含了将要发送的完整的数据信息，其长短不需一致。报文在传输过程中会不断地封装成分组、包、帧来传输，封装的方式就是添加一些控制信息组成的首部，那些就是报文头。</p>
</li>
<li><p>报文段(segment) —— 传输层<br>组成报文的每个分组，将传输层分组称为报文段（面向连接（TCP）的数据传输）。报文段是起始点和目的地都是传输层的信息单元。</p>
</li>
<li><p>数据报(datagram) —— 传输层<br>面向无连接(Connectionless Communication)的数据传输，其工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报。通常是指起始点和目的地都使用无连接网络服务的网络层的信息单元。(指IP数据报)</p>
</li>
<li><p>数据包(packet) —— 网络层<br>是网络层传输的数据单元，也成为“包”。包中带有足够寻址信息（IP地址），可独立地从源主机传输到目的主机。它的起始和目的地是网络层。</p>
</li>
<li><p>帧(frame) —— 数据链路层<br>帧是数据链路层的传输单元。它将上层传入的数据添加一个头部和尾部，组成了帧。它的起始点和目的点都是数据链路层。</p>
</li>
</ul>
<ul>
<li><strong>以太网帧</strong><br><img src="/2025/02/12/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E5%8F%91%E9%80%81/ethernet-frame-format.png"></li>
</ul>
<p>在以太网链路上的数据包称作以太帧。以太帧起始部分由前导码和帧开始符组成。后面紧跟着一个以太网报头，以MAC地址说明目的地址和源地址。帧的中部是该帧负载的包含其他协议报头的数据包（例如IP协议）。以太帧由一个32位冗余校验码结尾。它用于检验数据传输是否出现损坏。<br>在以太网帧中，<em>Destination Address(目的地址)<em>放在最前面。接收方收到一个以太网帧后，最先处理</em>Destination Address</em>字段。如果发现该帧不是发给自己的，后面的字段以及数据就不需要处理了。</p>
<p>什么是帧间距（IFG）</p>
<p>网络设备和组件在接收一个帧之后，需要一段短暂的时间来恢复并为接收下一帧.做准备互联网帧间隙共20字节，包括：</p>
<ul>
<li>以太网最小帧间隙 12Byte</li>
<li>数据链路层帧 前导码 7Byte，用于时钟同步 This is a sequence of alternate 0s and 1s that denotes the beginning of the frame and enables bit synchronization between the sender and receiver.</li>
<li>帧开始标识 1Byte （标识帧的开始）</li>
</ul>
<ul>
<li>比特流(bitstream) —— 物理层</li>
</ul>
<hr>
<h1 id="各层间数据传递"><a href="#各层间数据传递" class="headerlink" title="各层间数据传递"></a>各层间数据传递</h1><ul>
<li>不同的协议层对数据包有不同的称谓，在传输层叫做段(segment)，在⽹络层叫做数据包 (datagram)，在链路层叫做帧(frame)。</li>
<li>应⽤层数据通过协议栈发到⽹络上时，每层协议都要加上⼀个数据⾸部(header)，称为封装 (Encapsulation)。</li>
<li>⾸部信息中包含了⼀些类似于⾸部有多⻓，载荷(payload)有多⻓，上层协议是什么等信息。</li>
<li>数据封装成帧后发到传输介质上，到达⽬的主机后每层协议再剥掉相应的⾸部，根据⾸部中的 “上层协议字段” 将数据交给对应的上层协议处理。</li>
</ul>
<p><img src="/2025/02/12/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E5%8F%91%E9%80%81/NetworkPacket.png" title="Dissecting a Network Packet"></p>
<hr>
<h1 id="数据的封装过程（从上至下）"><a href="#数据的封装过程（从上至下）" class="headerlink" title="数据的封装过程（从上至下）"></a>数据的封装过程（从上至下）</h1><p>传输层：报文被分为多个报文段，每个报文段上加上TCP首部（主要包含端口、源端口），变为TCP报文段；(注：TCP叫TCP报文段，UDP叫UDP数据报,也有人叫UDP段)<br>网络层：将TCP报文段加上IP数据包首部（主要包含目的IP，源IP），变成数据包；<br>数据链路层：将数据包加上目标MAC与源MAC、FCS(Frame Check Sequence)、变成MAC帧。<br>物理层：将帧变为比特流，传递给PC3物理层。</p>
<hr>
<h1 id="数据传输计量单位"><a href="#数据传输计量单位" class="headerlink" title="数据传输计量单位"></a>数据传输计量单位</h1><p>Maximum Transmission Unit：最大传输单元，链路层的帧中的数据部分的最大字节数，以太网中的一般为1500字节。</p>
<p>Maximum Segment Size：TCP的报文段中的数据部分的最大字节数，MTU减去IPv4的Header和TCP的Header。IPv4的Header和TCP的Header一般都是20字节，则 1500-20-20 &#x3D; 1460字节。</p>
<p>Maximum Segment Lifetime：报文最大生存时间。报文在网络上存在的最长时间，超过这个时间报文将被丢弃。当TCP执行一个主动关闭，并发回最后一个ACK,该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。存在这个规则导致一个后果就是在这个2MSL的时间内，该地址上的链接（客户端地址、端口和服务器端的地址、端口）不能被使用。比如我们在建立一个链接后关闭链接然后迅速重启链接，那么就会出现端口不可用的情况。</p>
<p><img src="/2025/02/12/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E5%8F%91%E9%80%81/TCP.png" title="Packet exchange for TCP connection"></p>
<p>Round Trip Time：往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据结束，到发送端收到来自接收端的确认数据总共经历的时延。RTT&#x3D;传播时延（往返哒）+ 排队时延（路由器和交换机的）+ 数据处理时延（应用程序的）。</p>
<p>Time To Live：IP头部有一个TTL域，TTL是time to live的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值，但不是具体的时间，而是存储了一个IP数据报可以经过的最大路由数，每经过一个路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。</p>
<hr>
<h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h1><p>数据包：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a3192048/article/details/84671340">https://blog.csdn.net/a3192048/article/details/84671340</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/02/12/TCP-IP-%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/12/TCP-IP-%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">TCP/IP 五层网络模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-12 17:26:08" itemprop="dateCreated datePublished" datetime="2025-02-12T17:26:08+08:00">2025-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-28 15:58:52" itemprop="dateModified" datetime="2025-02-28T15:58:52+08:00">2025-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TCP-IP网络模型各层协议功能"><a href="#TCP-IP网络模型各层协议功能" class="headerlink" title="TCP&#x2F;IP网络模型各层协议功能"></a>TCP&#x2F;IP网络模型各层协议功能</h1><h2 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h2><p>应用层是网络通信的最高层，它定义了应用程序和网络之间的接口。在这一层，用户可以直接与应用程序进行交互。常见的应用层协议有HTTP、FTP、SMTP等。</p>
<ul>
<li><p><strong>Proxy</strong><br>A proxy server (forward proxy) takes requests from a client and forwards them to the internet, a reverse proxy takes requests from the internet and forwards them to a server.</p>
</li>
<li><p><strong>Transport Layer Security</strong><br>SSL&#x2F;TLS uses asymmetric encryption is used to establish a secure session between a client and a server, and symmetric encryption is used to exchange data within the secured session.<br>密钥：数据的加密是通过密钥进行的，通过密钥，明文被加密成密文。密钥分为对称加密密钥和非对称加密密钥。密钥为一段随机生成的数，通常以 .pem或者 .key文件保存，可以使用Openssl生成。<br>对称加密：加密解密都是使用同一个密钥。服务器使用该密钥进行加密，经过传输后客户端使用该密钥解密。该方式效率高，但存在安全隐患。<br>非对称加密：非对称加密具有一个密钥对，公钥和私钥，理论上来说公钥和私钥并不区分，便于区分将保存在本地的那个叫做私钥，将需要传输给对方的那个叫做公钥。数据经过私钥加密后，只能由对应的公钥解密，同样数据经过公钥加密后，只能由对应的私钥解密。那么只要客户端拥有服务器的公钥，通过公钥加密报文，服务器用自己的私钥解密就可以实现对传输过程的加密。非对称加密的效率比较低，而且仍有被中间人攻击的风险。<br>证书颁发机构：CA机构是权威的第三方，机构本身具有自己的CA公钥与CA私钥，CA公钥是发给全体互联网成员的，可以将其称为CA证书。服务器需要将自己的 公钥以及认证信息经过HASH加密后发改CA机构，CA机构使用CA私钥对提交的信息进行加密，这就得到了带有数字签名的数据。在使用时使用CA公钥对带有数字签名的数据解密，得到经HASH后的数据，同时将公钥以及认证信息 经过HASH加密后与CA解密后的数据比对，验证电子签名的安全性。</p>
</li>
</ul>
<h2 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2. 传输层"></a>2. 传输层</h2><p>传输层负责在源主机和目标主机（端到端）之间建立数据传输通道，主要协议有TCP和UDP。</p>
<h2 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h2><p>网络层负责在网络上寻址和路由数据包。它定义了数据在网络中的传输路径，使得数据可以从源主机传输到目标主机。常见的网络层协议有IP协议。</p>
<ul>
<li><strong>地址解析协议</strong><br>ARP（Address Resolution Protocol，地址解析协议）是用来将IP地址解析为MAC地址的协议。主机或三层网络设备上会维护一张ARP表，用于存储IP地址和MAC地址的映射关系</li>
</ul>
<h2 id="4-数据链路层"><a href="#4-数据链路层" class="headerlink" title="4. 数据链路层"></a>4. 数据链路层</h2><p>数据链路层协议负责将网络层传输的数据分组封装成帧，传输到物理层，并通过物理介质进行传输。常见的数据链路层协议有以太网和Wi-Fi等。</p>
<h2 id="5-物理层"><a href="#5-物理层" class="headerlink" title="5. 物理层"></a>5. 物理层</h2><p>物理层是网络通信的最底层，它负责在物理介质上传输比特流。它定义了物理连接的特性，如电压、频率等。常见的物理层介质有光纤、双绞线等。</p>
<hr>
<h1 id="二层设备和三层设备"><a href="#二层设备和三层设备" class="headerlink" title="二层设备和三层设备"></a>二层设备和三层设备</h1><p>二层设备是工作数据链路层的设备。二层交换机可以识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。具体的工作流程如下：<br>（1） 当交换机从某个端口收到一个数据包，它先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上的；<br>（2） 再去读取包头中的目的MAC地址，并在地址表中查找相应的端口；<br>（3） 如表中有与这目的MAC地址对应的端口，把数据包直接复制到这端口上；<br>（4） 如表中找不到相应的端口则把数据包广播到所有端口上，当目的机器对源机器回应时，交换机又可以学习一目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。<br>不断的循环这个过程，对于全网的MAC地址信息都可以学习到，二层交换机就是这样建立和维护它自己的地址表。</p>
<p>三层设备是工作在网络层的设备。路由器是最常用的三层设备，利用不同网络的ID号（即IP地址）来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络，有时这些第三层的地址也称为协议地址或者网络地址。</p>
<hr>
<h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h1><p>详解TCP&#x2F;IP五层网络模型：<a target="_blank" rel="noopener" href="https://blog.csdn.net/2201_75437633/article/details/137373813">https://blog.csdn.net/2201_75437633/article/details/137373813</a><br>TLS&#x2F;SSL：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44640149/article/details/134667685">https://blog.csdn.net/weixin_44640149/article/details/134667685</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/02/11/C-%E4%B8%AD%E7%9A%84unsafe%E3%80%81fixed%E5%92%8Cchecked%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/11/C-%E4%B8%AD%E7%9A%84unsafe%E3%80%81fixed%E5%92%8Cchecked%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">C#中的unsafe、fixed和checked关键字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-11 15:19:51" itemprop="dateCreated datePublished" datetime="2025-02-11T15:19:51+08:00">2025-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-28 15:54:40" itemprop="dateModified" datetime="2025-02-28T15:54:40+08:00">2025-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">C#编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Stack-vs-Heap"><a href="#Stack-vs-Heap" class="headerlink" title="Stack vs. Heap"></a>Stack vs. Heap</h1><p>In C#, primitive types such as int, double, and bool are all structs. Arrays of int are allocated on heap as int structs, only pointer to them will be allocated on stack.<br>To make a fixed size array be stored on stack, you need to use the <em>stackalloc</em> keyword, either with <em>unsafe</em> block or <em>Span</em> type.</p>
<figure class="highlight cs"><figcaption><span>unsafe关键词示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">unsafe</span> <span class="title">foo</span>(<span class="params"><span class="built_in">int</span> length</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>* bar = <span class="keyword">stackalloc</span> <span class="built_in">int</span> [length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><figcaption><span>type Span示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>(<span class="params"><span class="built_in">int</span> length</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Span&lt;<span class="built_in">int</span>&gt; bar = <span class="keyword">stackalloc</span> <span class="built_in">int</span> [length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h1><p>unsafe关键字用于声明不安全的代码块。在C#中，默认情况下，代码是安全的，这意味着它遵循.NET的安全规则，包括对内存的访问控制。使用unsafe关键字可以告诉编译器，你了解并信任这段代码，即使它可能违反安全规则。</p>
<p>使用unsafe关键字需要满足一些条件：</p>
<ol>
<li>你的项目必须被标记为允许不安全代码（通过在项目的属性中设置Allow Unsafe Code）。</li>
<li>你的代码必须在unsafe代码块中。</li>
<li>你必须使用fixed关键字来固定内存块。</li>
</ol>
<h1 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h1><p>fixed 关键字在 C# 中主要用于固定内存地址，通常与不安全代码（unsafe）一起使用。当你在不安全的代码中直接访问内存时，使用 fixed 关键字可以确保内存地址在程序运行期间保持不变。</p>
<p>使用 fixed 关键字的主要原因是：在垃圾回收过程中，垃圾回收器可能会移动内存中的对象。如果一个指针指向一个对象，而该对象在垃圾回收过程中被移动，那么该指针就会变得无效。通过使用 fixed 关键字，你可以告诉垃圾回收器不要移动这个对象，从而确保指针始终指向有效的内存地址。</p>
<figure class="highlight cs"><figcaption><span>fixed关键字示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">class</span> <span class="title">Example</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">int</span>[] array = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];  </span><br><span class="line">    <span class="keyword">fixed</span> <span class="built_in">int</span>* ptr = <span class="keyword">stackalloc</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Method</span>()</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">int</span>* p = ptr; <span class="comment">// 这里的p指向一个固定的内存地址  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            *(p + i) = array[i]; <span class="comment">// 将数组的值赋给固定的内存地址  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个固定大小的数组 ptr，并在方法 Method 中使用它来修改另一个数组 array 的值。因为 ptr 是用 fixed 关键字声明的，所以它指向的内存地址在 Method 执行期间是固定的，不会发生位移</p>
<h1 id="checked"><a href="#checked" class="headerlink" title="checked"></a>checked</h1><p>checked关键字用于在算术运算中控制溢出检查。默认情况下，当一个整数运算结果超出了该类型的表示范围时，会抛出System.OverflowException异常。使用checked关键字可以强制执行溢出检查，并在发生溢出时抛出异常。</p>
<figure class="highlight cs"><figcaption><span>checked关键字示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">int</span> maxValue = <span class="built_in">int</span>.MaxValue;  </span><br><span class="line">        <span class="built_in">int</span>* ptr = <span class="keyword">stackalloc</span> <span class="built_in">int</span>[] &#123; maxValue &#125;; <span class="comment">// 创建一个固定大小的数组  </span></span><br><span class="line">        <span class="keyword">fixed</span> (<span class="built_in">int</span>* p = ptr) <span class="comment">// 使用fixed关键字固定内存地址  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            *(p + <span class="number">1</span>) = <span class="number">0</span>; <span class="comment">// 尝试访问超出数组范围的内存，这会导致未定义的行为（除非使用unsafe代码）  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        Console.WriteLine(ptr[<span class="number">1</span>]); <span class="comment">// 这将输出0，因为我们在不安全的代码中修改了内存  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">uint</span> a = <span class="built_in">uint</span>.MaxValue;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">unchecked</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(a + <span class="number">3</span>);  <span class="comment">// output: 2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    checked</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(a + <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (OverflowException e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(e.Message);  <span class="comment">// output: Arithmetic operation resulted in an overflow.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出:<br>2<br>Arithmetic operation resulted in an overflow.</p>
</blockquote>
<p>如果没有checked，那么输出的就是2，不会抛出异常也不会提示结果实际上已经超出范围了。导致程序发生一些不可预估的问题；</p>
<p>在这个例子中，我们创建了一个固定大小的数组，并在一个fixed代码块中修改了数组外的内存。因为我们使用了unsafe和fixed关键字，所以这是合法的。但请注意，试图访问数组外的内存是一种未定义的行为，可能会导致程序崩溃或其他不可预测的结果。</p>
<hr>
<h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31418645/article/details/135245645">https://blog.csdn.net/qq_31418645/article/details/135245645</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/02/11/%E6%98%BE%E7%A4%BA%E5%99%A8%E5%92%8CVSync%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/11/%E6%98%BE%E7%A4%BA%E5%99%A8%E5%92%8CVSync%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">显示器和VSync工作原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-11 14:31:30" itemprop="dateCreated datePublished" datetime="2025-02-11T14:31:30+08:00">2025-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-27 14:42:35" itemprop="dateModified" datetime="2025-02-27T14:42:35+08:00">2025-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%B2%E6%9F%93/" itemprop="url" rel="index"><span itemprop="name">渲染</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="显示器类别"><a href="#显示器类别" class="headerlink" title="显示器类别"></a>显示器类别</h1><p>根据显示技术和用途的不同，显示器可以分为多种类型，主要包括：</p>
<ul>
<li><strong>阴极射线管显示器（CRT）</strong></li>
<li><strong>液晶显示器（LCD）</strong></li>
<li><strong>发光二极管显示器（LED）</strong></li>
<li><strong>等离子显示器（PDP）</strong></li>
<li><strong>有机发光二极管显示器（OLED）</strong></li>
<li><strong>量子点显示器（QLED）</strong></li>
</ul>
<h1 id="VSync-工作原理"><a href="#VSync-工作原理" class="headerlink" title="VSync 工作原理"></a>VSync 工作原理</h1><p>What is VSync? VSync stands for Vertical Synchronization. The basic idea is that synchronizes your FPS with your monitor’s refresh rate. The purpose is to eliminate something called “tearing”. I will describe all these things here.  </p>
<p>Every CRT monitor has a refresh rate. It’s specified in Hz (Hertz, cycles per second). It is the number of times the monitor updates the display per second. Different monitors support different refresh rates at different resolutions. They range from 60Hz at the low end up to 100Hz and higher. Note that this isn’t your FPS as your games report it. If your monitor is set at a specific refresh rate, it always updates the screen at that rate, even if nothing on it is changing. On an LCD, things work differently. Pixels on an LCD stay lit until they are told to change; they don’t have to be refreshed. However, because of how VGA (and DVI) works, the LCD must still poll the video card at a certain rate for new frames. This is why LCD’s still have a “refresh rate” even though they don’t actually have to refresh.  </p>
<p>I think everyone here understands FPS. It’s how many frames the video card can draw per second. Higher is obviously better. However, during a fast paced game, your FPS rarely stays the same all the time. It moves around as the complexity of the image the video card has to draw changes based on what you are seeing. This is where tearing comes in.  </p>
<p>Tearing is a phenomenon that gives a disjointed image. The idea is as if you took a photograph of something, then rotated your vew maybe just 1 degree to the left and took a photograph of that, then cut the two pictures in half and taped the top half of one to the bottom half of the other. The images would be similar but there would be a notable difference in the top half from the bottom half. This is what is called tearing on a visual display. It doesn’t always have to be cut right in the middle. It can be near the top or the bottom and the separation point can actually move up or down the screen, or seem to jump back and forth between two points.  </p>
<p>Why does this happen? Lets take a specific example. Let’s say your monitor is set to a refresh rate of 75Hz. You’re playing your favorite game and you’re getting 100FPS right now. That means that the mointor is updating itself 75 times per second, but the video card is updating the display 100 times per second, that’s 33% faster than the mointor. So that means in the time between screen updates, the video card has drawn one frame and a third of another one. That third of the next frame will overwrite the top third of the previous frame and then get drawn on the screen. The video card then finishes the last 2 thirds of that frame, and renders the next 2 thirds of the next frame and then the screen updates again. As you can see this would cause this tearing effect as 2 out of every 3 times the screen updates, either the top third or bottom third is disjointed from the rest of the display. This won’t really be noticeable if what is on the screen isn’t changing much, but if you’re looking around quickly or what not this effect will be very apparant.  </p>
<p>Now this is where the common misconception comes in. Some people think that the solution to this problem is to simply create an FPS cap equal to the refresh rate. So long as the video card doesn’t go faster than 75 FPS, everything is fine, right? Wrong.  </p>
<p>Before I explain why, let me talk about double-buffering. Double-buffering is a technique that mitigates the tearing problem somewhat, but not entirely. Basically you have a frame buffer and a back buffer. Whenever the monitor grabs a frame to refresh with, it pulls it from the frame buffer. The video card draws new frames in the back buffer, then copies it to the frame buffer when it’s done. However the copy operation still takes time, so if the monitor refreshes in the middle of the copy operation, it will still have a torn image.  </p>
<p>VSync solves this problem by creating a rule that says the back buffer can’t copy to the frame buffer until right after the monitor refreshes. With a framerate higher than the refresh rate, this is fine. The back buffer is filled with a frame, the system waits, and after the refresh, the back buffer is copied to the frame buffer and a new frame is drawn in the back buffer, effectively capping your framerate at the refresh rate.  </p>
<p>That’s all well and good, but now let’s look at a different example. Let’s say you’re playing the sequel to your favorite game, which has better graphics. You’re at 75Hz refresh rate still, but now you’re only getting 50FPS, 33% slower than the refresh rate. That means every time the monitor updates the screen, the video card draws 2&#x2F;3 of the next frame. So lets track how this works. The monitor just refreshed, and frame 1 is copied into the frame buffer. 2&#x2F;3 of frame 2 gets drawn in the back buffer, and the monitor refreshes again. It grabs frame 1 from the frame buffer for the first time. Now the video card finishes the last third of frame 2, but it has to wait, because it can’t update until right after a refresh. The monitor refreshes, grabbing frame 1 the second time, and frame 2 is put in the frame buffer. The video card draws 2&#x2F;3 of frame 3 in the back buffer, and a refresh happens, grabbing frame 2 for the first time. The last third of frame 3 is draw, and again we must wait for the refresh, and when it happens, frame 2 is grabbed for the second time, and frame 3 is copied in. We went through 4 refresh cycles but only 2 frames were drawn. At a refresh rate of 75Hz, that means we’ll see 37.5FPS. That’s noticeably less than 50FPS which the video card is capable of. This happens because the video card is forced to waste time after finishing a frame in the back buffer as it can’t copy it out and it has nowhere else to draw frames.  </p>
<p>Essentially this means that with double-buffered VSync, the framerate can only be equal to a discrete set of values equal to Refresh &#x2F; N where N is some positive integer. That means if you’re talking about 60Hz refresh rate, the only framerates you can get are 60, 30, 20, 15, 12, 10, etc etc. You can see the big gap between 60 and 30 there. Any framerate between 60 and 30 your video card would normally put out would get dropped to 30.  </p>
<p>Now maybe you can see why people loathe it. Let’s go back to the original example. You’re playing your favorite game at 75Hz refresh and 100FPS. You turn VSync on, and the game limits you to 75FPS. No problem, right? Fixed the tearing issue, it looks better. You get to an area that’s particularly graphically intensive, an area that would drop your FPS down to about 60 without VSync. Now your card cannot do the 75FPS it was doing before, and since VSync is on, it has to do the next highest one on the list, which is 37.5FPS. So now your game which was running at 75FPS just halved it’s framerate to 37.5 instantly. Whether or not you find 37.5FPS smooth doesn’t change the fact that the framerate just cut in half suddenly, which you would notice. This is what people hate about it.  </p>
<p>If you’re playing a game that has a framerate that routinely stays above your refresh rate, then VSync will generally be a good thing. However if it’s a game that moves above and below it, then VSync can become annoying. Even worse, if the game plays at an FPS that is just below the refresh rate (say you get 65FPS most of the time on a refresh rate of 75Hz), the video card will have to settle for putting out much less FPS than it could (37.5FPS in that instance). This second example is where the percieved drop in performance comes in. It looks like VSync just killed your framerate. It did, technically, but it isn’t because it’s a graphically intensive operation. It’s simply the way it works.  </p>
<p>All hope is not lost however. There is a technique called triple-buffering that solves this VSync problem. Lets go back to our 50FPS, 75Hz example. Frame 1 is in the frame buffer, and 2&#x2F;3 of frame 2 are drawn in the back buffer. The refresh happens and frame 1 is grabbed for the first time. The last third of frame 2 are drawn in the back buffer, and the first third of frame 3 is drawn in the second back buffer (hence the term triple-buffering). The refresh happens, frame 1 is grabbed for the second time, and frame 2 is copied into the frame buffer and the first part of frame 3 into the back buffer. The last 2&#x2F;3 of frame 3 are drawn in the back buffer, the refresh happens, frame 2 is grabbed for the first time, and frame 3 is copied to the frame buffer. The process starts over. This time we still got 2 frames, but in only 3 refresh cycles. That’s 2&#x2F;3 of the refresh rate, which is 50FPS, exactly what we would have gotten without it. Triple-buffering essentially gives the video card someplace to keep doing work while it waits to transfer the back buffer to the frame buffer, so it doesn’t have to waste time. Unfortunately, triple-buffering isn’t available in every game, and in fact it isn’t too common. It also can cost a little performance to utilize, as it requires extra VRAM for the buffers, and time spent copying all of them around. However, triple-buffered VSync really is the key to the best experience as you eliminate tearing without the downsides of normal VSync (unless you consider the fact that your FPS is capped a downside… which is silly because you can’t see an FPS higher than your refresh anyway).  </p>
<p>I hope this was informative, and will help people understand the intracacies of VSync (and hopefully curb the “VSync, yes or no?” debates!). Generally, if triple buffering isn’t available, you have to decide whether the discrete framerate limitations of VSync and the issues that can cause are worth the visual improvement of the elimination of tearing. It’s a personal preference, and it’s entirely up to you.</p>
<hr>
<h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h1><p>VSync explanation: <a target="_blank" rel="noopener" href="https://hardforum.com/threads/how-vsync-works-and-why-people-loathe-it.928593/">https://hardforum.com/threads/how-vsync-works-and-why-people-loathe-it.928593/</a></p>
<p>CRT显示器和各类显示器比较：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_69378371/article/details/145129033">https://blog.csdn.net/m0_69378371/article/details/145129033</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://miaopasss.github.io/2025/02/10/%E5%85%B6%E6%AC%A1%E5%9D%90%E6%A0%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/exciting-usagi.gif">
      <meta itemprop="name" content="Haotian Luo">
      <meta itemprop="description" content="<font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乌啦呀哈呀哈乌啦！">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/10/%E5%85%B6%E6%AC%A1%E5%9D%90%E6%A0%87/" class="post-title-link" itemprop="url">其次坐标</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-10 16:06:35" itemprop="dateCreated datePublished" datetime="2025-02-10T16:06:35+08:00">2025-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-26 11:37:11" itemprop="dateModified" datetime="2025-02-26T11:37:11+08:00">2025-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>其次函数：输入函数扩大 a 倍，其响应函数相应的也扩大 a 倍。</strong></p>
<p>Unity中的齐次坐标是一种在计算机图形学中常用的表示坐标的方式，通过引入一个额外的维度来扩展传统的笛卡尔坐标系，以便进行几何变换和矩阵运算。‌齐次坐标将n维的向量或矩阵用n+1维来表示，这样可以明确区分向量和点，并且能够方便地处理平移变换‌。</p>
<p>齐次坐标通过增加一个额外的分量w来实现。当w≠0时，可以将齐次坐标转化为普通的笛卡尔坐标；当w&#x3D;0时，表示一个无穷远的点‌。这种表示方法使得4x4矩阵（仿射矩阵）能够同时进行线性变换和平移变换，而3x3矩阵（线性矩阵）则只能进行旋转和缩放等线性变换‌。</p>
<p>在Unity中，齐次坐标主要用于顶点着色器和片段着色器中，进行模型的变换、投影和视图转换等操作。通过使用齐次坐标，可以统一处理各种变换，使得着色器的实现更加统一和高效‌</p>
<p><img src="/2025/02/10/%E5%85%B6%E6%AC%A1%E5%9D%90%E6%A0%87/p1.png" title="其次坐标的性质"> <br></p>
<p><img src="/2025/02/10/%E5%85%B6%E6%AC%A1%E5%9D%90%E6%A0%87/p2.png" title="二维其次坐标"> <br></p>
<p><img src="/2025/02/10/%E5%85%B6%E6%AC%A1%E5%9D%90%E6%A0%87/p3.png" title="其次坐标的优势"> <br></p>
<p><img src="/2025/02/10/%E5%85%B6%E6%AC%A1%E5%9D%90%E6%A0%87/p4.png" title="欧式变换"> <br></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Haotian Luo"
      src="/images/exciting-usagi.gif">
  <p class="site-author-name" itemprop="name">Haotian Luo</p>
  <div class="site-description" itemprop="description"><font face="KAI" size=4 color=firebrick>

赤团开时斜飞去，<br>
最不安神晴又复雨。

</font>
</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/miaopasss" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;miaopasss" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hubery.luo@icloud.com" title="E-Mail → mailto:hubery.luo@icloud.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Haotian Luo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://miaopasss.github.io/',]
      });
      });
  </script>

</body>
</html>
